1) DISPLAY NUMBER OF EMPLOYEES JOINED AFTER 15TH OF THE MONTH.

SELECT COUNT(EMPLOYEE_ID) FROM NJCT_A_EMPLOYEES WHERE EXTRACT(DAY FROM HIRE_DATE) >  15;
--NOT SURE


2) DISPLAY THE COUNTRY ID AND NUMBER OF CITIES WE HAVE IN THE COUNTRY.

SELECT COUNTRY_ID,COUNT(CITY) FROM NJCT_A_LOCATIONS GROUP BY COUNTRY_ID;
--NOT SURE CUZ SUPPOSE THE WE HAVE COUNTRY CODE BUT NO EMPLOYEE FROM THAT COUNTRY CITY
--    \_(*.*)_/


3) DISPLAY AVERAGE SALARY OF EMPLOYEES IN EACH DEPARTMENT WHO HAVE COMMISSION PERCENTAGE.

SELECT DEPARTMENT_ID,AVG(SALARY) FROM NJCT_A_EMPLOYEES
WHERE COMMISSION_PCT IS NOT NULL
GROUP BY DEPARTMENT_ID;
/*SELECT AVG(SALARY),DEPARTMENT_NAME FROM EMPLOYEES
WHERE COMMISSION_PCT = '&COMMISSION_PCT'--COMMISION PERCENT
GROUP BY DEPARTMENT_ID;*/


4) DISPLAY JOB ID, NUMBER OF EMPLOYEES, SUM OF SALARY,\
AND DIFFERENCE BETWEEN HIGHEST SALARY
AND LOWEST SALARY OF THE EMPLOYEES OF THE JOB.

SELECT JOB_ID,COUNT(JOB_ID) AS EMPLOYEE,
SUM(SALARY) AS SUMSALARY,MAX(SALARY)-MIN(SALARY) AS DIFFERENCE 
FROM NJCT_A_EMPLOYEES GROUP BY JOB_ID;
/*
---NOT TRIED BUT MAY BE 100%  RIGHT?? :(
--BY INNER JOIN

SELECT J.JOB_ID,COUNT(E.EMPLOYEE_ID),SUM(E.SALARY),J.MAX_SALARY-J.MIN_SALARY 
FROM JOBS J 
INNER JOIN EMPLOYEE E ON J.JOB_ID = E.JOB_ID 
GROUP BY JOB_ID;
--WITHOUT JOIN
SELECT J.JOB_ID,COUNT(E.EMPLOYEE_ID),SUM(E.SALARY),J.MAX_SALARY-J.MIN_SALARY 
FROM JOBS J,EMPLOYEE E
WHERE J.JOB_ID = E.JOB_ID
GROUP BY JOB_ID;
*/


5) DISPLAY JOB ID FOR JOBS WITH AVERAGE SALARY MORE THAN 10000.

SELECT J.JOB_ID,AVG(E.SALARY) FROM NJCT_A_JOBS J
JOIN NJCT_A_EMPLOYEES E ON J.JOB_ID = E.JOB_ID
GROUP BY E.JOB_ID
HAVING AVG(SALARY)>10000;



6) DISPLAY YEARS IN WHICH MORE THAN 10 EMPLOYEES JOINED.
--EXACTLY REQUIRED QUERY
SELECT EXTRACT(YEAR FROM HIRE_DATE) AS REQUIREDYEAR,COUNT(HIRE_DATE)
FROM NJCT_A_EMPLOYEES
GROUP BY EXTRACT(YEAR FROM HIRE_DATE)
HAVING COUNT(HIRE_DATE) > 10;

/*
---(*-*)TRIAL :)
SELECT EXTRACT(YEAR FROM HIRE_DATE) AS YEAR,COUNT(HIRE_DATE) AS 'EMPLOYEE_HIRED' FROM EMPLOYEES
WHERE COUNT(HIRE_DATE) > 10
GROUP BY HIRE_DATE; 

SELECT DATEDIFF(HIRE_DATE,SYSDATE) FROM EMPLOYEES;

DESC EMPLOYEES;

SELECT * FROM EMPLOYEES WHERE DATEDIFF(HIRE_DATE,SYSDATE) > 1;

SELECT COUNT(HIRE_DATE),EXTRACT(YEAR FROM HIRE_DATE) FROM EMPLOYEES GROUP BY EXTRACT(YEAR FROM HIRE_DATE);

*/

7) DISPLAY DEPARTMENTS IN WHICH MORE THAN FIVE EMPLOYEES HAVE COMMISSION PERCENTAGE.
SELECT DEPARTMENT_ID,DEPARTMENT_NAME FROM NJCT_A_DEPARTMENTS
WHERE DEPARTMENT_ID IN (
SELECT DEPARTMENT_ID FROM NJCT_A_EMPLOYEES 
GROUP BY DEPARTMENT_ID
HAVING COUNT(COMMISSION_PCT) > 5);

/*
SELECT DEPARTMENT_NAME FROM DEPARTMENTS
WHERE DEPARTMENT_ID IN (
    SELECT DEPARTMENT_ID FROM EMPLOYEES 
    GROUP BY DEPARTMENT_ID
    HAVING COUNT(COMMISSION_PCT) > 5);
*/


8) DISPLAY EMPLOYEE ID FOR EMPLOYEES WHO DID MORE THAN ONE JOB IN THE PAST.

SELECT EMPLOYEE_ID FROM NJCT_A_JOB_HISTORY
GROUP BY EMPLOYEE_ID
HAVING COUNT(EMPLOYEE_ID) > 1;
/*
SELECT EMPLOYEE_ID FROM JOB_HISTORY
GROUP BY EMPLOYEE_ID
HAVING COUNT(EMPLOYEE_ID) > 1;
*/


9) DISPLAY JOB ID OF JOBS THAT WERE DONE BY MORE THAN 3 EMPLOYEES FOR MORE THAN 100 DAYS.

SELECT JOB_ID FROM NJCT_A_EMPLOYEES 
WHERE TO_DATE(HIRE_DATE,'YYYY-MM-DD')-TO_DATE(SYSDATE,'YYYY-MM-DD') > 100
GROUP BY JOB_ID
HAVING COUNT(JOB_ID) > 3;
/*
SELECT TO_CHAR(SYSDATE,'DDD') FROM DUAL;
SELECT TO_DATE(HIRE_DATE, 'YYYY-MM-DD') -  TO_DATE(SYSDATE, 'YYYY-MM-DD') DATEDIFF FROM NJCT_A_EMPLOYEES;
*/


10) DISPLAY DEPARTMENT ID, YEAR, AND NUMBER OF EMPLOYEES JOINED.

SELECT DEPARTMENT_ID,EXTRACT(YEAR FROM HIRE_DATE) AS Y_E_A_R,COUNT(EMPLOYEE_ID) AS NO_OF_EMPLOYEE FROM NJCT_A_EMPLOYEES 
GROUP BY EXTRACT(YEAR FROM HIRE_DATE),DEPARTMENT_ID
ORDER BY DEPARTMENT_ID;
/*SELECT DEPARTMENT_ID,EXTRACT(YEAR FROM HIRE_DATE) AS 'YEAR',COUNT(EMPLOYEE_ID) AS 'NO OF EMPLOYEE'
FROM EMPLOYEE 
GROUP BY EXTRACT(YEAR FROM HIRE_DATE);
*/


11) DISPLAY DEPARTMENTS WHERE ANY MANAGER IS MANAGING MORE THAN 5 EMPLOYEES.

SELECT MANAGER_ID, COUNT(MANAGER_ID) AS UNDEREMPLOYEE FROM NJCT_A_EMPLOYEES
GROUP BY MANAGER_ID
HAVING COUNT(MANAGER_ID) > 5;

/*
SELECT DEPARTMENT_NAME FROM DEPARTMENT1
WHERE DEPARTMENT_ID = (
SELECT DEPARTMENT_ID FROM EMPLOYEE
GROUP BY MANAGER_ID
HAVING COUNT(MANAGER_ID) > 5
);
*/

12) DISPLAY DEPARTMENT NAME, MANAGER NAME, AND CITY.
/*
DEPARTMENTS -> DEPARTMENT_NAME,MANAGER_ID;
EMPLOYEES -> MANAGER_NAME;
LOCATIONS -> CITY;
*/

SELECT D.DEPARTMENT_NAME,E.FIRST_NAME,L.CITY FROM NJCT_A_DEPARTMENTS D
JOIN NJCT_A_EMPLOYEES E ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
JOIN NJCT_A_LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID;

13) DISPLAY COUNTRY NAME, CITY, AND DEPARTMENT NAME.

SELECT CN.COUNTRY_NAME,L.CITY,D.DEPARTMENT_NAME FROM NJCT_A_LOCATIONS L
JOIN NJCT_A_COUNTRIES CN ON L.COUNTRY_ID = CN.COUNTRY_ID
JOIN NJCT_A_DEPARTMENTS D ON L.LOCATION_ID = D.LOCATION_ID;


14) DISPLAY JOB TITLE, DEPARTMENT NAME, EMPLOYEE LAST NAME, STARTING DATE FOR ALL JOBS FROM 2000 TO 2005.

SELECT J.JOB_TITLE,D.DEPARTMENT_NAME,E.LAST_NAME FROM NJCT_A_JOB_HISTORY JH
JOIN NJCT_A_JOBS J ON JH.JOB_ID = J.JOB_ID
JOIN NJCT_A_EMPLOYEES E ON JH.EMPLOYEE_ID = E.EMPLOYEE_ID
JOIN NJCT_A_DEPARTMENTS D ON JH.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE EXTRACT(YEAR FROM JH.START_DATE) BETWEEN 2000 AND 2005;

INSERT INTO NJCT_A_JOB_HISTORY VALUES(116,'19-MAR-2001','18-MAR-2003',21,502);

INSERT INTO NJCT_A_JOB_HISTORY VALUES(115,'19-MAR-1999','18-MAR-2001',31,801);
SELECT * FROM NJCT_A_JOB_HISTORY;


15) DISPLAY JOB TITLE AND AVERAGE SALARY OF EMPLOYEES

SELECT JT.JOB_TITLE,TEMP.AVGSALARY FROM NJCT_A_JOBS JT
JOIN ( SELECT E.JOB_ID,AVG(E.SALARY) AVGSALARY FROM NJCT_A_JOBS J
JOIN NJCT_A_EMPLOYEES E ON E.JOB_ID = J.JOB_ID
GROUP BY E.JOB_ID) TEMP ON JT.JOB_ID = TEMP.JOB_ID;


16) DISPLAY DETAILS OF JOBS THAT WERE DONE BY ANY EMPLOYEE WHO IS CURRENTLY DRAWING MORE THAN 15000 OF SALARY.

SELECT DISTINCT J.JOB_ID,J.JOB_TITLE FROM NJCT_A_JOBS J
JOIN NJCT_A_EMPLOYEES E ON J.JOB_ID = E.JOB_ID
WHERE E.SALARY > 15000;

17) DISPLAY DEPARTMENT NAME, MANAGER NAME, AND SALARY OF THE MANAGER FOR ALL MANAGERS WHOSE EXPERIENCE IS MORE THAN 5 YEARS.

SELECT D.DEPARTMENT_NAME,TEMP.FIRST_NAME,TEMP.SALARY FROM NJCT_A_DEPARTMENTS D
JOIN (SELECT DISTINCT M.DEPARTMENT_ID,M.FIRST_NAME,M.SALARY FROM NJCT_A_EMPLOYEES M
JOIN NJCT_A_EMPLOYEES E ON E.MANAGER_ID = M.EMPLOYEE_ID
WHERE (EXTRACT(YEAR FROM SYSDATE)-EXTRACT(YEAR FROM M.HIRE_DATE))>5) TEMP
ON D.DEPARTMENT_ID = TEMP.DEPARTMENT_ID;
/*
SELECT DISTINCT M.FIRST_NAME,M.SALARY FROM NJCT_A_EMPLOYEES M
JOIN NJCT_A_EMPLOYEES E ON E.MANAGER_ID = M.EMPLOYEE_ID
WHERE (EXTRACT(YEAR FROM SYSDATE)-EXTRACT(YEAR FROM M.HIRE_DATE))>5;

*/


18) DISPLAY EMPLOYEE NAME, JOB TITLE FOR THE JOBS EMPLOYEE DID IN THE PAST WHERE THE JOB WAS DONE LESS THAN SIX MONTHS.

SELECT E.FIRST_NAME,J.JOB_TITLE FROM NJCT_A_EMPLOYEES E
JOIN (SELECT M.EMPLOYEE_ID,M.JOB_ID FROM NJCT_A_JOB_HISTORY M
JOIN NJCT_A_JOB_HISTORY Y ON EXTRACT(YEAR FROM M.START_DATE) = EXTRACT(YEAR FROM Y.END_DATE) AND M.EMPLOYEE_ID = Y.EMPLOYEE_ID
WHERE (EXTRACT(MONTH FROM M.END_DATE)-EXTRACT(MONTH FROM M.START_DATE))<6) TEMP
ON E.EMPLOYEE_ID = TEMP.EMPLOYEE_ID
JOIN NJCT_A_JOBS J ON TEMP.JOB_ID = J.JOB_ID;


19) DISPLAY DEPARTMENT NAME, AVERAGE SALARY AND NUMBER OF EMPLOYEES WITH COMMISSION WITHIN THE DEPARTMENT.

SELECT D.DEPARTMENT_NAME,TEMP.AVGSALARY,TEMP.COMM_COUNT FROM NJCT_A_DEPARTMENTS D
JOIN (SELECT DEPARTMENT_ID,AVG(SALARY) AVGSALARY,COUNT(COMMISSION_PCT) COMM_COUNT FROM NJCT_A_EMPLOYEES 
GROUP BY DEPARTMENT_ID) TEMP
ON TEMP.DEPARTMENT_ID = D.DEPARTMENT_ID;



20) DISPLAY THE MONTH IN WHICH MORE THAN 5 EMPLOYEES JOINED IN ANY DEPARTMENT LOCATED IN SYDNEY.
--HAVE TO THINK ABOUT IT AGAIN
SELECT LOC.MONTH FROM NJCT_A_LOCATIONS L
JOIN (SELECT TEMP.MONTH,D.LOCATION_ID FROM NJCT_A_DEPARTMENTS D
JOIN (SELECT DEPARTMENT_ID,EXTRACT(MONTH FROM HIRE_DATE) MONTH FROM NJCT_A_EMPLOYEES
GROUP BY EXTRACT(YEAR FROM HIRE_DATE),EXTRACT(MONTH FROM HIRE_DATE),DEPARTMENT_ID
HAVING COUNT(EXTRACT(MONTH FROM HIRE_DATE)) > 5) TEMP
ON D.DEPARTMENT_ID = TEMP.DEPARTMENT_ID) LOC
ON L.LOCATION_ID = LOC.LOCATION_ID
WHERE CITY LIKE 'SYDENY';

/*	THIS QUERY DIVES THE DEPARTMENT_ID
SELECT DEPARTMENT_ID,COUNT(EXTRACT(MONTH FROM HIRE_DATE)),EXTRACT(MONTH FROM HIRE_DATE),EXTRACT(YEAR FROM HIRE_DATE) FROM NJCT_A_EMPLOYEES
GROUP BY EXTRACT(YEAR FROM HIRE_DATE),EXTRACT(MONTH FROM HIRE_DATE),DEPARTMENT_ID
HAVING COUNT(EXTRACT(MONTH FROM HIRE_DATE)) > 1;
*/

/*	THIS QUERY WILL GIVE LOACTIONS 
SELECT LOCATION_ID FROM NJCT_A_DEPARTMENTS D
JOIN (SELECT DEPARTMENT_ID FROM NJCT_A_EMPLOYEES
GROUP BY EXTRACT(YEAR FROM HIRE_DATE),EXTRACT(MONTH FROM HIRE_DATE),DEPARTMENT_ID
HAVING COUNT(EXTRACT(MONTH FROM HIRE_DATE)) > 1) TEMP
ON D.DEPARTMENT_ID = TEMP.DEPARTMENT_ID;
*/

/*
SELECT CITY FROM NJCT_A_LOCATIONS L
JOIN (SELECT LOCATION_ID FROM NJCT_A_DEPARTMENTS D
JOIN (SELECT DEPARTMENT_ID FROM NJCT_A_EMPLOYEES
GROUP BY EXTRACT(YEAR FROM HIRE_DATE),EXTRACT(MONTH FROM HIRE_DATE),DEPARTMENT_ID
HAVING COUNT(EXTRACT(MONTH FROM HIRE_DATE)) > 1) TEMP
ON D.DEPARTMENT_ID = TEMP.DEPARTMENT_ID) LOC
ON L.LOCATION_ID = LOC.LOCATION_ID
WHERE CITY LIKE 'SYDENY';
*/


21) DISPLAY DETAILS OF DEPARTMENTS IN WHICH THE MAXIMUM SALARY IS MORE THAN 10000.

SELECT D.DEPARTMENT_ID,D.DEPARTMENT_NAME FROM NJCT_A_DEPARTMENTS D
JOIN (SELECT DISTINCT DEPARTMENT_ID FROM NJCT_A_EMPLOYEES
WHERE JOB_ID IN (SELECT JOB_ID FROM NJCT_A_JOBS
WHERE MAX_SALARY > 10000)) TEMP
ON D.DEPARTMENT_ID = TEMP.DEPARTMENT_ID;



22) DISPLAY JOBS INTO WHICH EMPLOYEES JOINED IN THE CURRENT YEAR.

SELECT J.JOB_ID,JOB_TITLE FROM NJCT_A_JOBS J
JOIN (SELECT JOB_ID FROM NJCT_A_EMPLOYEES
WHERE EXTRACT(YEAR FROM HIRE_DATE) = EXTRACT(YEAR FROM SYSDATE)) JI
ON J.JOB_ID = JI.JOB_ID;



23) DISPLAY EMPLOYEES WHO DID NOT DO ANY JOB IN THE PAST.

SELECT EMPLOYEE_ID,FIRST_NAME,LAST_NAME FROM NJCT_A_EMPLOYEES
WHERE EMPLOYEE_ID NOT IN(SELECT EMPLOYEE_ID FROM NJCT_A_JOB_HISTORY);

24) DISPLAY JOB TITLE AND AVERAGE SALARY FOR EMPLOYEES WHO DID A JOB IN THE PAST.

SELECT JOB_TITLE,TEMP.AVG_SALARY FROM NJCT_A_JOBS J
JOIN (SELECT JOB_ID,AVG(SALARY) AVG_SALARY FROM NJCT_A_EMPLOYEES
WHERE EMPLOYEE_ID IN (SELECT EMPLOYEE_ID FROM NJCT_A_JOB_HISTORY)
GROUP BY JOB_ID) TEMP
ON J.JOB_ID = TEMP.JOB_ID;
/*
SELECT JOB_ID,AVG(SALARY) FROM NJCT_A_EMPLOYEES
GROUP BY JOB_ID;
*/


25) DISPLAY COUNTRY NAME, CITY, AND NUMBER OF DEPARTMENTS WHERE DEPARTMENT HAS MORE THAN 5 EMPLOYEES.

SELECT C.COUNTRY_NAME,TEMP1.CITY,TEMP1.NO_OF_DEPT FROM NJCT_A_COUNTRIES C
JOIN (SELECT L.LOCATION_ID,L.CITY,L.COUNTRY_ID,TEMP.NO_OF_DEPT FROM NJCT_A_LOCATIONS L
JOIN (SELECT LOCATION_ID,COUNT(LOCATION_ID) NO_OF_DEPT FROM NJCT_A_DEPARTMENTS D 
JOIN (SELECT DEPARTMENT_ID FROM NJCT_A_EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING COUNT(DEPARTMENT_ID) > 3) ED
ON D.DEPARTMENT_ID = ED. DEPARTMENT_ID
GROUP BY LOCATION_ID) TEMP
ON TEMP.LOCATION_ID = L.LOCATION_ID) TEMP1
ON C.COUNTRY_ID = TEMP1.COUNTRY_ID;
/*
SELECT LOCATION_ID,COUNT(LOCATION_ID) NO_OF_DEPT FROM NJCT_A_DEPARTMENTS D
JOIN (SELECT DEPARTMENT_ID FROM NJCT_A_EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING COUNT(DEPARTMENT_ID) > 3) ED
ON D.DEPARTMENT_ID = ED. DEPARTMENT_ID
GROUP BY LOCATION_ID;
*/




26) DISPLAY DETAILS OF MANAGER WHO MANAGES MORE THAN 5 EMPLOYEES.

SELECT DET.EMPLOYEE_ID MANAGER,DET.FIRST_NAME,DET.LAST_NAME,TEMP.NO_OF_EMP FROM NJCT_A_EMPLOYEES DET
JOIN (SELECT M.EMPLOYEE_ID,COUNT(M.EMPLOYEE_ID) NO_OF_EMP FROM NJCT_A_EMPLOYEES M
JOIN NJCT_A_EMPLOYEES E ON M.EMPLOYEE_ID = E.MANAGER_ID
GROUP BY M.EMPLOYEE_ID
HAVING COUNT(M.EMPLOYEE_ID) > 5) TEMP
ON DET.EMPLOYEE_ID = TEMP.EMPLOYEE_ID;

27) DISPLAY THE DEPARTMENTS INTO WHICH NO EMPLOYEE JOINED IN LAST TWO YEARS.

SELECT * FROM NJCT_A_DEPARTMENTS
WHERE DEPARTMENT_ID NOT IN(SELECT DISTINCT DEPARTMENT_ID FROM NJCT_A_EMPLOYEES
WHERE (EXTRACT(YEAR FROM SYSDATE)-EXTRACT(YEAR FROM HIRE_DATE)) < 2);


28) DISPLAY THE DETAILS OF DEPARTMENTS IN WHICH THE MAX SALARY IS GREATER THAN 10000 FOR EMPLOYEES WHO DID A JOB IN THE PAST.

SELECT * FROM NJCT_A_DEPARTMENTS D
JOIN (SELECT JH.DEPARTMENT_ID FROM NJCT_A_JOBS J
JOIN NJCT_A_JOB_HISTORY JH
ON JH.JOB_ID = J.JOB_ID
WHERE MAX_SALARY > 10000) TEMP
ON D.DEPARTMENT_ID = TEMP.DEPARTMENT_ID;

29) DISPLAY THIRD HIGHEST SALARY OF ALL EMPLOYEES

SELECT MIN(SALARY) FROM (
SELECT SALARY FROM NJCT_A_EMPLOYEES 
WHERE SALARY IS NOT NULL 
ORDER BY SALARY DESC
) WHERE ROWNUM<=3;
/*SELECT MIN(SALARY)
FROM (SELECT DISTINCT SALARY FROM NJCT_A_EMPLOYEES
WHERE ROWNUM < 4
ORDER BY SALARY DESC);*/

1) FIND OUT THE NAME OF THE EMPLOYEE AND NAME OF THE DEPARTMENT FOR THE EMPLOYEE WHO IS
MANAGING FOR EMPLOYEE 103.

DECLARE

V_EID NJCT_A_EMPLOYEES.EMPLOYEE_ID%TYPE;
V_FN NJCT_A_EMPLOYEES.FIRST_NAME%TYPE;
V_DID NJCT_A_EMPLOYEES.DEPARTMENT_ID%TYPE;
V_DN NJCT_A_DEPARTMENTS.DEPARTMENT_NAME%TYPE;

BEGIN

V_EID := &V_EID;

SELECT E.FIRST_NAME,E.DEPARTMENT_ID INTO V_FN,V_DID FROM NJCT_A_EMPLOYEES E
JOIN NJCT_A_EMPLOYEES M ON E.EMPLOYEE_ID = M.MANAGER_ID
WHERE M.EMPLOYEE_ID = V_EID;

SELECT DEPARTMENT_NAME INTO V_DN FROM NJCT_A_DEPARTMENTS WHERE DEPARTMENT_ID = V_DID;

DBMS_OUTPUT.PUT_LINE('MANAGER NAME :- '|| V_FN);
DBMS_OUTPUT.PUT_LINE('DEPARTMENT NAME :- '|| V_DN);

END;


2) DISPLAY THE YEAR IN WHICH MAXIMUM NUMBER OF EMPLOYEES JOINED ALONG WITH HOW MANY JOINED IN EACH MONTH IN THAT YEAR.
DECLARE
V_MAX_COUNT NUMBER;
V_YEAR NUMBER;
V_MONTH NUMBER;
V_COUNT NUMBER;


CURSOR CURMAXYEAR(V_MAX NUMBER) IS SELECT EXTRACT(YEAR FROM HIRE_DATE) FROM NJCT_A_EMPLOYEES
GROUP BY EXTRACT(YEAR FROM HIRE_DATE)
HAVING COUNT(EXTRACT(YEAR FROM HIRE_DATE)) = V_MAX;


CURSOR CURMONTHWISE(V_MONTH_YEAR NUMBER)
IS SELECT EXTRACT(MONTH FROM HIRE_DATE),COUNT(EXTRACT(MONTH FROM HIRE_DATE)) FROM NJCT_A_EMPLOYEES
WHERE EXTRACT(YEAR FROM HIRE_DATE) = V_MONTH_YEAR
GROUP BY EXTRACT(MONTH FROM HIRE_DATE);

BEGIN

SELECT MAX(COUNT(EXTRACT(YEAR FROM HIRE_DATE))) INTO V_MAX_COUNT  FROM NJCT_A_EMPLOYEES
GROUP BY EXTRACT(YEAR FROM HIRE_DATE);

OPEN CURMAXYEAR(V_MAX_COUNT);
LOOP--OUTER LOOP
FETCH CURMAXYEAR INTO V_YEAR;
EXIT WHEN CURMAXYEAR%NOTFOUND;
DBMS_OUTPUT.PUT_LINE('---------------------------------------');
DBMS_OUTPUT.PUT_LINE('YEAR : '||V_YEAR ||' NO. OF EMPLOYEE JOINED : '||V_MAX_COUNT);
DBMS_OUTPUT.PUT_LINE('---------------------------------------');


OPEN CURMONTHWISE(V_YEAR);
LOOP--INNER LOOP
FETCH CURMONTHWISE INTO V_MONTH,V_COUNT;
EXIT WHEN CURMONTHWISE%NOTFOUND;
DBMS_OUTPUT.PUT_LINE('|-MONTH : '||TO_CHAR(TO_DATE(V_MONTH, 'MM'), 'MON')||' NO OF EMPLOYEE HIRED : '||V_COUNT);
END LOOP;--END OF INNER LOOP
CLOSE CURMONTHWISE;

END LOOP;--END OF OUTER LOOP
CLOSE CURMAXYEAR;


EXCEPTION 
WHEN INVALID_CURSOR THEN
DBMS_OUTPUT.PUT_LINE('CURSOR IS INVALID, KINDLY CONTACT THE ADMINISTRATOR');
END;

-- DECLARE
-- V_MAX_COUNT NUMBER;
-- V_YEAR NUMBER;
-- V_MONTH NUMBER;
-- V_COUNT NUMBER;

-- CURSOR CURMONTHWISE(V_MONTH_YEAR NUMBER)
-- IS SELECT EXTRACT(MONTH FROM HIRE_DATE),COUNT(EXTRACT(MONTH FROM HIRE_DATE)) FROM NJCT_A_EMPLOYEES
-- WHERE EXTRACT(YEAR FROM HIRE_DATE) = V_MONTH_YEAR
-- GROUP BY EXTRACT(MONTH FROM HIRE_DATE);

-- BEGIN

-- SELECT MAX(COUNT(EXTRACT(YEAR FROM HIRE_DATE))) INTO V_MAX_COUNT FROM NJCT_A_EMPLOYEES
-- GROUP BY EXTRACT(YEAR FROM HIRE_DATE);

-- SELECT EXTRACT(YEAR FROM HIRE_DATE) INTO V_YEAR FROM NJCT_A_EMPLOYEES
-- GROUP BY EXTRACT(YEAR FROM HIRE_DATE)
-- HAVING COUNT(EXTRACT(YEAR FROM HIRE_DATE)) = V_MAX_COUNT;

-- DBMS_OUTPUT.PUT_LINE('YEAR : '||V_YEAR);
-- DBMS_OUTPUT.PUT_LINE('NO. OF EMPLOYEE JOINED : '||V_MAX_COUNT);

-- OPEN CURMONTHWISE(V_YEAR);
-- LOOP
-- FETCH CURMONTHWISE INTO V_MONTH,V_COUNT;

-- DBMS_OUTPUT.PUT_LINE('MONTH : '||V_MONTH||' NO OF EMPLOYEE HIRED : '||V_COUNT);

-- EXIT WHEN CURMONTHWISE%NOTFOUND;
-- END LOOP;

-- CLOSE CURMONTHWISE;
-- EXCEPTION 
-- WHEN INVALID_CURSOR THEN
-- DBMS_OUTPUT.PUT_LINE('CURSOR IS INVALID, KINDLY CONTACT THE ADMINISTRATOR');
-- END;

3) CHANGE SALARY OF EMPLOYEE 130 TO THE SALARY OF THE EMPLOYEE WITH FIRST NAME ‘JOE’. IF JOE IS
NOT FOUND THEN TAKE AVERAGE SALARY OF ALL EMPLOYEES. IF MORE THAN ONE EMPLOYEE WITH FIRST 
NAME ‘JOE’ IS FOUND THEN TAKE THE LEAST SALARY OF THE EMPLOYEES WITH FIRST NAME JOE. [USE
EXCEPTIONS] 

3) CHANGE SALARY OF EMPLOYEE 130 TO THE SALARY OF THE EMPLOYEE WITH FIRST NAME ‘JOE’. IF JOE IS
NOT FOUND THEN TAKE AVERAGE SALARY OF ALL EMPLOYEES. IF MORE THAN ONE EMPLOYEE WITH FIRST 
NAME ‘JOE’ IS FOUND THEN TAKE THE LEAST SALARY OF THE EMPLOYEES WITH FIRST NAME JOE. [USE
EXCEPTIONS]
/*
SALARY OF 130 TO THE FN->JOE
IF JOE IS NOTFOUND 
THEN 
SALARY OF 130 = AVG(SALARY)
ELSE IF MORE THAN ONE JOE IS FOUND THE MIN(SALARY OF JOE);
*/
DECLARE 

V_SALARY NJCT_A_EMPLOYEES.SALARY%TYPE;

BEGIN

SELECT SALARY INTO V_SALARY FROM NJCT_A_EMPLOYEES WHERE FIRST_NAME LIKE 'JOE';
UPDATE NJCT_A_EMPLOYEES SET SALARY = V_SALARY WHERE EMPLOYEE_ID = 130;
DBMS_OUTPUT.PUT_LINE('SALARY UPDATED SUCCESSFULLY');

EXCEPTION
WHEN NO_DATA_FOUND THEN
  SELECT AVG(SALARY) INTO V_SALARY FROM NJCT_A_EMPLOYEES;
  UPDATE NJCT_A_EMPLOYEES SET SALARY = V_SALARY WHERE EMPLOYEE_ID = 130;
  DBMS_OUTPUT.PUT_LINE('SALARY UPDATED SUCCESSFULLY');
WHEN TOO_MANY_ROWS THEN
  SELECT MIN(SALARY) INTO V_SALARY FROM NJCT_A_EMPLOYEES WHERE FIRST_NAME LIKE 'JOE';
  UPDATE NJCT_A_EMPLOYEES SET SALARY = V_SALARY WHERE EMPLOYEE_ID = 130;
  DBMS_OUTPUT.PUT_LINE('SALARY UPDATED SUCCESSFULLY');
WHEN OTHERS THEN
  DBMS_OUTPUT.PUT_LINE('AN ERROR OCCURRED');

END;
/*
SELECT EMPLOYEE_ID,FIRST_NAME,SALARY FROM NJCT_A_EMPLOYEES ORDER BY FIRST_NAME;

SELECT MIN(SALARY) FROM NJCT_A_EMPLOYEES WHERE FIRST_NAME LIKE 'C'
GROUP BY FIRST_NAME ;S
*/

4) DISPLAY JOB TITLE AND NAME OF THE EMPLOYEE WHO JOINED THE JOB FIRST DAY. 

DECLARE
V_FIRSTNAME NJCT_A_EMPLOYEES.FIRST_NAME%TYPE;
V_JOB_TITLE NJCT_A_JOBS.JOB_TITLE%TYPE;
V_COUNT NUMBER;

CURSOR CUR_FIRST_DAY
IS SELECT JOB_TITLE,FIRST_NAME FROM NJCT_A_JOBS J
JOIN NJCT_A_EMPLOYEES E ON E.JOB_ID = J.JOB_ID
WHERE TO_DATE(HIRE_DATE,'YYYY-MM-DD')-TO_DATE(SYSDATE,'YYYY-MM-DD')  = 0;

BEGIN

SELECT COUNT(EMPLOYEE_ID) INTO V_COUNT FROM NJCT_A_EMPLOYEES WHERE TO_DATE(HIRE_DATE,'YYYY-MM-DD')-TO_DATE(SYSDATE,'YYYY-MM-DD')  = 0;

IF V_COUNT > 0 THEN
OPEN CUR_FIRST_DAY;

LOOP
FETCH CUR_FIRST_DAY INTO V_JOB_TITLE,V_FIRSTNAME;
EXIT WHEN CUR_FIRST_DAY%NOTFOUND; 
DBMS_OUTPUT.PUT_LINE('JOB : '||V_JOB_TITLE||' || EMPLOYEE NAME : '||V_FIRSTNAME);
END LOOP;

CLOSE CUR_FIRST_DAY;
ELSE
DBMS_OUTPUT.PUT_LINE('NO ONE HAVE FIRST DAY TODAY!!!');
END IF;

EXCEPTION
WHEN INVALID_CURSOR THEN --INVALID_CURSOR
DBMS_OUTPUT.PUT_LINE('INVALID CURSOR CHECK AGAIN!!');
END;
/*
SELECT JOB_TITLE,FIRST_NAME FROM NJCT_A_JOBS J
JOIN NJCT_A_EMPLOYEES E ON E.JOB_ID = J.JOB_ID
WHERE TO_DATE(HIRE_DATE,'YYYY-MM-DD')-TO_DATE(SYSDATE,'YYYY-MM-DD')  = 0;
*/
-- DECLARE
-- V_FIRSTNAME NJCT_A_EMPLOYEES.FIRST_NAME%TYPE;
-- V_JOB_TITLE NJCT_A_JOBS.JOB_TITLE%TYPE;

-- CURSOR CUR_FIRST_DAY
-- IS SELECT JOB_TITLE,FIRST_NAME FROM NJCT_A_JOBS J
-- JOIN NJCT_A_EMPLOYEES E ON E.JOB_ID = J.JOB_ID
-- WHERE TO_DATE(HIRE_DATE,'YYYY-MM-DD')-TO_DATE(SYSDATE,'YYYY-MM-DD')  = 0;

-- BEGIN

-- OPEN CUR_FIRST_DAY;

-- IF CUR_FIRST_DAY%ROWCOUNT = 0 THEN
-- DBMS_OUTPUT.PUT_LINE('NO ONE HAVE FIRST DAY TODAY!!!');
-- ELSE 
-- LOOP
-- FETCH CUR_FIRST_DAY INTO V_JOB_TITLE,V_FIRSTNAME;
-- EXIT WHEN CUR_FIRST_DAY%NOTFOUND;
-- DBMS_OUTPUT.PUT_LINE('JOB : '||V_JOB_TITLE||' EMPLOYEE NAME :'||V_FIRSTNAME);
-- END LOOP;
-- END IF;

-- CLOSE CUR_FIRST_DAY;

-- EXCEPTION
-- WHEN INVALID_CURSOR THEN --INVALID_CURSOR
-- DBMS_OUTPUT.PUT_LINE('INVALID CURSOR CHECK AGAIN!!');
-- END;

/*
OPEN CUR_FIRST_DAY;
LOOP
FETCH CUR_FIRST_DAY INTO V_JOB_TITLE,V_FIRSTNAME;
EXIT WHEN CUR_FIRST_DAY%NOTFOUND;
DBMS_OUTPUT.PUT_LINE('JOB : '||V_JOB_TITLE||' EMPLOYEE NAME :'||V_FIRSTNAME);
END LOOP;
CLOSE CUR_FIRST_DAY;
EXCEPTION
WHEN NO_DATA_FOUND THEN --INVALID_CURSOR
DBMS_OUTPUT.PUT_LINE('NO ONE HAVE FIRST DAY TODAY!!!');
*/



/*
SELECT * FROM NJCT_A_EMPLOYEES;
UPDATE NJCT_A_EMPLOYEES SET HIRE_DATE = '19-12-20' WHERE EMPLOYEE_ID =117;


OPEN CUR_FIRST_DAY;

IF CUR_FIRST_DAY%NOTFOUND THEN
DBMS_OUTPUT.PUT_LINE('NO ONE HAVE FIRST DAY TODAY!!!');
ELSE 
LOOP
FETCH CUR_FIRST_DAY INTO V_JOB_TITLE,V_FIRSTNAME;
EXIT WHEN CUR_FIRST_DAY%NOTFOUND;
DBMS_OUTPUT.PUT_LINE('JOB : '||V_JOB_TITLE||' EMPLOYEE NAME :'||V_FIRSTNAME);
END LOOP;
END IF;

CLOSE CUR_FIRST_DAY;

EXCEPTION
WHEN INVALID_CURSOR THEN --INVALID_CURSOR
DBMS_OUTPUT.PUT_LINE('INVALID CURSOR CHECK AGAIN!!');

*/

5) ENSURE NO CHANGES CAN BE MADE TO EMPLOYEES TABLE BEFORE 6AM AND AFTER 10PM IN A DAY.

SELECT TO_CHAR(CURRENT_DATE, 'HH24') FROM DUAL; 
/*
CREATE OR REPLACE TRIGGER TRG_SUNDAY
BEFORE INSERT ON EMPLOYEE
REFERENCING NEW AS NEW OLD AS OLD
FOR EACH ROW
BEGIN
    IF TO_CHAR(SYSDATE, 'D') = '1' THEN   ---SHOULD BE 1 RATHER THAN 7
        RAISE_APPLICATION_ERROR(-20000, 'CANNOT INSERT RECORD ON SUNDAY'); 
    END IF;
END;

FOR SUNDAY
*/

CREATE OR REPLACE TRIGGER NO_CHANGE_ON_NJCT_A_EMPLOYEES
BEFORE INSERT OR UPDATE OR DELETE ON NJCT_A_EMPLOYEES
FOR EACH ROW
DECLARE
V_TIME NUMBER;
BEGIN

SELECT TO_CHAR(CURRENT_DATE, 'HH24') INTO V_TIME FROM DUAL;

IF (V_TIME > 6 AND V_TIME < 22) THEN
RAISE_APPLICATION_ERROR(-20101, 'DML ALLOW BETWEEN 6AM AND 10PM');
ELSE
DBMS_OUTPUT.PUT_LINE('DML DONE SUCCESSFULLY!');
END IF;

END;

/*
CREATE OR REPLACE TRIGGER NO_CHANGE_ON_NJCT_A_EMPLOYEES
BEFORE INSERT OR UPDATE OR DELETE ON NJCT_A_EMPLOYEES
FOR EACH ROW
DECLARE
V_TIME NUMBER;
E_TIME EXCEPTION;
BEGIN

SELECT TO_CHAR(CURRENT_DATE, 'HH24') INTO V_TIME FROM DUAL;

IF (V_TIME > 6 AND V_TIME < 22) THEN
RAISE E_TIME;
ELSE
DBMS_OUTPUT.PUT_LINE('DML IS ALLOW THIS TIME!!!!');
END IF;

EXCEPTION
WHEN E_TIME THEN
DBMS_OUTPUT.PUT_LINE('DML IS NOT ALLOW THIS TIME!!!!');

END;

*/


6) WHENEVER THE JOB IS CHANGED FOR AN EMPLOYEE WRITE THE FOLLOWING DETAILS INTO JOB HISTORY.
EMPLOYEE ID, OLD JOB ID, OLD DEPARTMENT ID, HIRE DATE OF THE EMPLOYEE FOR START DATE, SYSTEM
DATE FOR END DATE. BUT IF A ROW IS ALREADY PRESENT FOR EMPLOYEE JOB HISTORY THEN THE START DATE
SHOULD BE THE END DATE OF THAT ROW +1.

CREATE OR REPLACE TRIGGER TRIGGER_NJCT_A_JOB_HISTORY
AFTER UPDATE OF JOB_ID
ON NJCT_A_EMPLOYEES
FOR EACH ROW
DECLARE
CURSOR CURTRIAL
IS
SELECT MAX(END_DATE) FROM NJCT_A_JOB_HISTORY WHERE EMPLOYEE_ID=:OLD.EMPLOYEE_ID;

V_COUNT NUMBER;
V_DATE DATE;

BEGIN

SELECT COUNT(EMPLOYEE_ID) INTO V_COUNT FROM NJCT_A_JOB_HISTORY WHERE EMPLOYEE_ID = :OLD.EMPLOYEE_ID;

IF (V_COUNT > 0) THEN
OPEN CURTRIAL;
FETCH CURTRIAL INTO V_DATE;

INSERT INTO NJCT_A_JOB_HISTORY 
VALUES (:OLD.EMPLOYEE_ID,V_DATE + 1,SYSDATE,:OLD.JOB_ID,:OLD.DEPARTMENT_ID);

CLOSE CURTRIAL;
DBMS_OUTPUT.PUT_LINE('IF');

ELSE
INSERT INTO NJCT_A_JOB_HISTORY 
VALUES (:OLD.EMPLOYEE_ID,:OLD.HIRE_DATE,SYSDATE,:OLD.JOB_ID,:OLD.DEPARTMENT_ID);

DBMS_OUTPUT.PUT_LINE('ELSE');
END IF;

END;
/*
CREATE OR REPLACE TRIGGER TRIGGER_JOB_HISTORY
AFTER UPDATE OF JOB_ID
ON NJCT_A_EMPLOYEES
FOR EACH ROW
BEGIN

INSERT INTO NJCT_A_JOB_HISTORY 
VALUES (:OLD.EMPLOYEE_ID,:OLD.HIRE_DATE,SYSDATE,:OLD.JOB_ID,:OLD.DEPARTMENT_ID);

END;

IF(EMPLOYEE_ID IS THERE IN NJCT_A_JOB_HISTORY) THEN
START_DATE = END_DATE + 1;
END_DATE = SYSDATE;
ELSE
INSERT INTO NJCT_A_JOB_HISTORY 
VALUES (:OLD.EMPLOYEE_ID,:OLD.HIRE_DATE,SYSDATE,:OLD.JOB_ID,:OLD.DEPARTMENT_ID);
END I0F;
*/
/*0000000000000000000*/
        /*FALSE TRIGGER WITH ERROR*/
        Errors: TRIGGER TRIGGER_JOB_HISTORY
        Line/Col: 8/1 PL/SQL: SQL Statement ignored
        Line/Col: 8/45 PL/SQL: ORA-00942: table or view does not exist
-- CREATE OR REPLACE TRIGGER TRIGGER_JOB_HISTORY
-- AFTER UPDATE OF JOB_ID
-- ON NJCT_A_EMPLOYEES
-- FOR EACH ROW
-- DECLARE
-- V_COUNT NUMBER;
-- V_DATE DATE;--V_EMPLOYEE_ID NJCT_A_JOB_HISTORY.EMPLOYEE_ID%TYPE;
-- CURSOR CURTRIAL(V_EMPLOYEE_ID NUMBER) IS 
-- SELECT END_DATE FROM (SELECT END_DATE FROM NJCT_A_JOB_HISTORY WHERE EMPLOYEE_ID = V_EMPLOYEE_ID ORDER BY END_DATE DESC) WHERE ROWNUM = 1;
-- BEGIN

-- SELECT COUNT(EMPLOYEE_ID) INTO V_COUNT FROM NJCT_A_JOB_HISTROY WHERE EMPLOYEE_ID = :OLD.EMPLOYEE_ID;

-- IF (V_COUNT = 0) THEN
-- INSERT INTO NJCT_A_JOB_HISTORY 
-- VALUES (:OLD.EMPLOYEE_ID,:OLD.HIRE_DATE,SYSDATE,:OLD.JOB_ID,:OLD.DEPARTMENT_ID);
-- ELSE
-- --V_EMPLOYEE_ID := :OLD.EMPLOYEE_ID;
-- OPEN CURTRIAL(:OLD.EMPLOYEE_ID);

-- FETCH CURTRIAL INTO V_DATE;

-- INSERT INTO NJCT_A_JOB_HISTORY 
-- VALUES (:OLD.EMPLOYEE_ID,V_DATE + 1,SYSDATE,:OLD.JOB_ID,:OLD.DEPARTMENT_ID);

-- CLOSE CURTRIAL;

-- END IF;

-- END;
/*0000000000000000000*/


















/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
WEEKDAY(START_DATE,END_DATE);

CREATE OR REPLACE FUNCTION FNX_WEEK_DAY_TRIAL(START_DATE DATE,LAST_DATE DATE)
RETURN NUMBER
IS
BEGIN
IF (START_DATE < LAST_DATE) THEN

END IF;
END;
/*

COMPARING DATE GRATER AND SMALLER

DECLARE
START_DATE DATE;
LAST_DATE DATE;
BEGIN 

START_DATE := '18-03-01';
LAST_DATE := '19-03-03';

IF (START_DATE < LAST_DATE) THEN
DBMS_OUTPUT.PUT_LINE('WRONG');
ELSE
DBMS_OUTPUT.PUT_LINE('RIGHT');
END IF;

END;
*/
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
-- PROCEDURE THAT GIVES DATE DIFFERENCE OF WEEKDAYS
DECLARE 
START_DATE DATE;
LAST_DATE DATE;
V_DATE DATE;
V_COUNT NUMBER;
BEGIN
START_DATE := '10-02-21';
LAST_DATE := '10-03-21';
IF (START_DATE < LAST_DATE) THEN

V_DATE := START_DATE;
V_COUNT := 0;

LOOP

IF(TO_CHAR(V_DATE,'D') != 1) THEN
V_COUNT := V_COUNT + 1;
END IF;
V_DATE := (V_DATE + 1);
EXIT WHEN V_DATE = LAST_DATE;

END LOOP;
DBMS_OUTPUT.PUT_LINE('NO. OF WEEK DAYS : '|| V_COUNT);
ELSE
DBMS_OUTPUT.PUT_LINE('CHECK THE DATES AGAIN!!!!');
END IF;
END;
-- FUNCTION OF ABOVE

/*
SELECT ( SYSDATE + 21 ) FROM DUAL;
*/
CREATE OR REPLACE FUNCTION FNX_WEEK_DAY_TRIAL(START_DATE DATE,LAST_DATE DATE)
RETURN NUMBER
IS

V_DATE DATE;
V_COUNT NUMBER;

BEGIN

IF (START_DATE < LAST_DATE) THEN

V_DATE := START_DATE;
V_COUNT := 0;

LOOP

IF(TO_CHAR(V_DATE,'D') != 1) THEN
V_COUNT := V_COUNT + 1;
END IF;
V_DATE := (V_DATE + 1);
EXIT WHEN V_DATE = LAST_DATE;

END LOOP;
RETURN V_COUNT;
ELSE
RETURN -1;
END IF;

END;

SELECT FNX_WEEK_DAY_TRIAL('10-02-21','10-03-21') FROM DUAL;
SELECT FNX_WEEK_DAY_TRIAL(TO_DATE(SYSDATE),'10-MAR-21') FROM DUAL;



--SELECT * FROM DICTIONARY WHERE TABLE_NAME LIKE '%TRIGG%';
-- SELECT * FROM USER_TRIGGERS WHERE TABLE_NAME LIKE'';

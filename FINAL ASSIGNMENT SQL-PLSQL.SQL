-- 1) DISPLAY NUMBER OF EMPLOYEES JOINED AFTER 15TH OF THE MONTH.
SELECT COUNT(EMPLOYEE_ID) FROM NJCT_A_EMPLOYEES
WHERE EXTRACT(MONTH FROM HIRE_DATE) = EXTRACT(MONTH FROM SYSDATE) AND EXTRACT(DAY FROM HIRE_DATE) >  15;

-- 2) DISPLAY THE COUNTRY ID AND NUMBER OF CITIES WE HAVE IN THE COUNTRY.
SELECT COUNTRY_ID,COUNT(CITY) FROM NJCT_A_LOCATIONS GROUP BY COUNTRY_ID;

-- 3) DISPLAY AVERAGE SALARY OF EMPLOYEES IN EACH DEPARTMENT WHO HAVE COMMISSION PERCENTAGE.
SELECT DEPARTMENT_ID,AVG(SALARY) FROM NJCT_A_EMPLOYEES
WHERE COMMISSION_PCT IS NOT NULL
GROUP BY DEPARTMENT_ID;

-- 4) DISPLAY JOB ID, NUMBER OF EMPLOYEES, SUM OF SALARY,AND DIFFERENCE BETWEEN HIGHEST SALARY AND LOWEST SALARY OF THE EMPLOYEES OF THE JOB.
SELECT JOB_ID,COUNT(JOB_ID) AS EMPLOYEE,
SUM(SALARY) AS SUMSALARY,MAX(SALARY)-MIN(SALARY) AS DIFFERENCE 
FROM NJCT_A_EMPLOYEES GROUP BY JOB_ID;

-- 5) DISPLAY JOB ID FOR JOBS WITH AVERAGE SALARY MORE THAN 10000.
SELECT J.JOB_ID,AVG(E.SALARY) FROM NJCT_A_JOBS J
JOIN NJCT_A_EMPLOYEES E ON J.JOB_ID = E.JOB_ID
GROUP BY E.JOB_ID
HAVING AVG(SALARY)>10000;

-- 6) DISPLAY YEARS IN WHICH MORE THAN 10 EMPLOYEES JOINED.
--EXACTLY REQUIRED QUERY
SELECT EXTRACT(YEAR FROM HIRE_DATE) AS REQUIREDYEAR,COUNT(HIRE_DATE)
FROM NJCT_A_EMPLOYEES
GROUP BY EXTRACT(YEAR FROM HIRE_DATE)
HAVING COUNT(HIRE_DATE) > 10;--(>7)

-- 7) DISPLAY DEPARTMENTS IN WHICH MORE THAN FIVE EMPLOYEES HAVE COMMISSION PERCENTAGE.
SELECT DEPARTMENT_ID,DEPARTMENT_NAME FROM NJCT_A_DEPARTMENTS
WHERE DEPARTMENT_ID IN (
SELECT DEPARTMENT_ID FROM NJCT_A_EMPLOYEES 
GROUP BY DEPARTMENT_ID
HAVING COUNT(COMMISSION_PCT) > 5);

-- 8) DISPLAY EMPLOYEE ID FOR EMPLOYEES WHO DID MORE THAN ONE JOB IN THE PAST.
SELECT EMPLOYEE_ID FROM NJCT_A_JOB_HISTORY
GROUP BY EMPLOYEE_ID
HAVING COUNT(EMPLOYEE_ID) >= 1;

-- 9) DISPLAY JOB ID OF JOBS THAT WERE DONE BY MORE THAN 3 EMPLOYEES FOR MORE THAN 100 DAYS.
--DD-MM-YYYY
SELECT JOB_ID FROM NJCT_A_EMPLOYEES 
WHERE TO_DATE(SYSDATE,'DD-MM-YYYY')-TO_DATE(HIRE_DATE,'DD-MM-YYYY') > 100
GROUP BY JOB_ID
HAVING COUNT(JOB_ID) > 3;
--YYYY-MM-DD
SELECT JOB_ID FROM NJCT_A_EMPLOYEES 
WHERE TO_DATE(HIRE_DATE,'YYYY-MM-DD')-TO_DATE(SYSDATE,'YYYY-MM-DD') > 100
GROUP BY JOB_ID
HAVING COUNT(JOB_ID) > 3;

-- 10) DISPLAY DEPARTMENT ID, YEAR, AND NUMBER OF EMPLOYEES JOINED.
SELECT DEPARTMENT_ID,EXTRACT(YEAR FROM HIRE_DATE) AS Y_E_A_R,COUNT(EMPLOYEE_ID) AS NO_OF_EMPLOYEE FROM NJCT_A_EMPLOYEES 
GROUP BY EXTRACT(YEAR FROM HIRE_DATE),DEPARTMENT_ID
ORDER BY DEPARTMENT_ID;

-- 11) DISPLAY DEPARTMENTS WHERE ANY MANAGER IS MANAGING MORE THAN 5 EMPLOYEES.
SELECT MANAGER_ID, COUNT(MANAGER_ID) AS UNDEREMPLOYEE FROM NJCT_A_EMPLOYEES
GROUP BY MANAGER_ID
HAVING COUNT(MANAGER_ID) > 5;

-- 12) DISPLAY DEPARTMENT NAME, MANAGER NAME, AND CITY.
/*
DEPARTMENTS -> DEPARTMENT_NAME,MANAGER_ID;
EMPLOYEES -> MANAGER_NAME;
LOCATIONS -> CITY;
*/
SELECT D.DEPARTMENT_NAME,E.FIRST_NAME,L.CITY FROM NJCT_A_DEPARTMENTS D
JOIN NJCT_A_EMPLOYEES E ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
JOIN NJCT_A_LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID;

-- 13) DISPLAY COUNTRY NAME, CITY, AND DEPARTMENT NAME.
--LEFT JOIN WITH ALL COUNTRY NAMES
SELECT CN.COUNTRY_NAME,L.CITY,D.DEPARTMENT_NAME FROM NJCT_A_COUNTRIES CN
LEFT JOIN NJCT_A_LOCATIONS L ON L.COUNTRY_ID = CN.COUNTRY_ID
LEFT JOIN NJCT_A_DEPARTMENTS D ON L.LOCATION_ID = D.LOCATION_ID
ORDER BY CN.COUNTRY_ID;
--QUERY WITHOUT LEFT JOIN
SELECT CN.COUNTRY_NAME,L.CITY,D.DEPARTMENT_NAME FROM NJCT_A_LOCATIONS L
JOIN NJCT_A_COUNTRIES CN ON L.COUNTRY_ID = CN.COUNTRY_ID
JOIN NJCT_A_DEPARTMENTS D ON L.LOCATION_ID = D.LOCATION_ID;

-- 14) DISPLAY JOB TITLE, DEPARTMENT NAME, EMPLOYEE LAST NAME, STARTING DATE FOR ALL JOBS FROM 2000 TO 2005.
SELECT J.JOB_TITLE,D.DEPARTMENT_NAME,E.LAST_NAME FROM NJCT_A_JOB_HISTORY JH
JOIN NJCT_A_JOBS J ON JH.JOB_ID = J.JOB_ID
JOIN NJCT_A_EMPLOYEES E ON JH.EMPLOYEE_ID = E.EMPLOYEE_ID
JOIN NJCT_A_DEPARTMENTS D ON JH.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE EXTRACT(YEAR FROM JH.START_DATE) BETWEEN 2000 AND 2005;

-- 15) DISPLAY JOB TITLE AND AVERAGE SALARY OF EMPLOYEES
SELECT JT.JOB_TITLE,AVG(E.SALARY) FROM NJCT_A_JOBS JT
JOIN NJCT_A_EMPLOYEES E ON E.JOB_ID = JT.JOB_ID
GROUP BY JT.JOB_ID,JT.JOB_TITLE;

-- 16) DISPLAY DETAILS OF JOBS THAT WERE DONE BY ANY EMPLOYEE WHO IS CURRENTLY DRAWING MORE THAN 15000 OF SALARY.
SELECT DISTINCT J.JOB_ID,J.JOB_TITLE FROM NJCT_A_JOBS J
JOIN NJCT_A_EMPLOYEES E ON J.JOB_ID = E.JOB_ID
WHERE E.SALARY > 15000;

-- 17) DISPLAY DEPARTMENT NAME, MANAGER NAME, AND SALARY OF THE MANAGER FOR ALL MANAGERS WHOSE EXPERIENCE IS MORE THAN 5 YEARS.
SELECT DISTINCT D.DEPARTMENT_NAME,M.EMPLOYEE_ID, M.FIRST_NAME,M.SALARY FROM NJCT_A_EMPLOYEES M
JOIN NJCT_A_EMPLOYEES E ON E.MANAGER_ID = M.EMPLOYEE_ID
JOIN NJCT_A_DEPARTMENTS D ON D.DEPARTMENT_ID = M.DEPARTMENT_ID
WHERE (EXTRACT(YEAR FROM SYSDATE)-EXTRACT(YEAR FROM M.HIRE_DATE))>5;

-- 18) DISPLAY EMPLOYEE NAME, JOB TITLE FOR THE JOBS EMPLOYEE DID IN THE PAST WHERE THE JOB WAS DONE LESS THAN SIX MONTHS.
SELECT E.FIRST_NAME,J.JOB_TITLE FROM NJCT_A_EMPLOYEES E
JOIN NJCT_A_JOB_HISTORY JH ON JH.EMPLOYEE_ID = E.EMPLOYEE_ID
JOIN NJCT_A_JOBS J ON J.JOB_ID = JH.JOB_ID
WHERE MONTHS_BETWEEN(TO_DATE(END_DATE,'DD-MM-YY'),TO_DATE(START_DATE,'DD-MM-YY')) < 6;

-- 19) DISPLAY DEPARTMENT NAME, AVERAGE SALARY AND NUMBER OF EMPLOYEES WITH COMMISSION WITHIN THE DEPARTMENT.
SELECT D.DEPARTMENT_NAME,TEMP.AVGSALARY,TEMP.COMM_COUNT FROM NJCT_A_DEPARTMENTS D
JOIN (SELECT DEPARTMENT_ID,AVG(SALARY) AVGSALARY,COUNT(COMMISSION_PCT) COMM_COUNT FROM NJCT_A_EMPLOYEES 
GROUP BY DEPARTMENT_ID) TEMP
ON TEMP.DEPARTMENT_ID = D.DEPARTMENT_ID;

-- 20) DISPLAY THE MONTH IN WHICH MORE THAN 5 EMPLOYEES JOINED IN ANY DEPARTMENT LOCATED IN SYDNEY.
SELECT EXTRACT(MONTH FROM HIRE_DATE),L.LOCATION_ID,L.CITY FROM NJCT_A_EMPLOYEES E
JOIN NJCT_A_DEPARTMENTS D ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
JOIN NJCT_A_LOCATIONS L ON L.LOCATION_ID = D.LOCATION_ID
WHERE CITY LIKE 'SYDNEY'
GROUP BY EXTRACT(MONTH FROM HIRE_DATE),L.LOCATION_ID,D.DEPARTMENT_ID,L.CITY
HAVING COUNT(EXTRACT(MONTH FROM HIRE_DATE)) > 5;

-- 21) DISPLAY DETAILS OF DEPARTMENTS IN WHICH THE MAXIMUM SALARY IS MORE THAN 10000.
SELECT DISTINCT D.DEPARTMENT_ID,D.DEPARTMENT_NAME FROM NJCT_A_EMPLOYEES E
JOIN NJCT_A_DEPARTMENTS D ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
JOIN NJCT_A_JOBS J ON J.JOB_ID = E.JOB_ID
WHERE J.MAX_SALARY > 10000;

-- 22) DISPLAY JOBS INTO WHICH EMPLOYEES JOINED IN THE CURRENT YEAR.
SELECT J.JOB_ID,J.JOB_TITLE FROM NJCT_A_EMPLOYEES E
JOIN NJCT_A_JOBS J ON J.JOB_ID = E.JOB_ID
WHERE EXTRACT(YEAR FROM HIRE_DATE) = EXTRACT(YEAR FROM SYSDATE);

-- 23) DISPLAY EMPLOYEES WHO DID NOT DO ANY JOB IN THE PAST.
SELECT EMPLOYEE_ID,FIRST_NAME,LAST_NAME FROM NJCT_A_EMPLOYEES
WHERE EMPLOYEE_ID NOT IN(SELECT EMPLOYEE_ID FROM NJCT_A_JOB_HISTORY);

-- 24) DISPLAY JOB TITLE AND AVERAGE SALARY FOR EMPLOYEES WHO DID A JOB IN THE PAST.
SELECT J.JOB_TITLE,JH.EMPLOYEE_ID,AVG(E.SALARY) FROM NJCT_A_JOB_HISTORY JH
JOIN NJCT_A_EMPLOYEES E ON JH.EMPLOYEE_ID = E.EMPLOYEE_ID
JOIN NJCT_A_JOBS J ON J.JOB_ID = E.JOB_ID
GROUP BY J.JOB_ID,JOB_TITLE,JH.EMPLOYEE_ID;

-- 25) DISPLAY COUNTRY NAME, CITY, AND NUMBER OF DEPARTMENTS WHERE DEPARTMENT HAS MORE THAN 5 EMPLOYEES.
SELECT C.COUNTRY_NAME,L.CITY,COUNT(D.LOCATION_ID) NO_OF_DEPARTMENT FROM NJCT_A_DEPARTMENTS D
JOIN (SELECT DEPARTMENT_ID FROM NJCT_A_EMPLOYEES GROUP BY DEPARTMENT_ID HAVING COUNT(DEPARTMENT_ID) > 5) DEPART ON DEPART.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN NJCT_A_LOCATIONS L ON L.LOCATION_ID = D.LOCATION_ID
JOIN NJCT_A_COUNTRIES C ON C.COUNTRY_ID = L.COUNTRY_ID
GROUP BY L.CITY,D.LOCATION_ID,C.COUNTRY_NAME;

-- 26) DISPLAY DETAILS OF MANAGER WHO MANAGES MORE THAN 5 EMPLOYEES.
SELECT M.EMPLOYEE_ID,M.FIRST_NAME,M.LAST_NAME,COUNT(E.MANAGER_ID) NO_OF_EMPLOYEE FROM NJCT_A_EMPLOYEES M
JOIN NJCT_A_EMPLOYEES E ON E.MANAGER_ID = M.EMPLOYEE_ID
GROUP BY M.EMPLOYEE_ID,E.MANAGER_ID,M.FIRST_NAME,M.LAST_NAME
HAVING COUNT(E.MANAGER_ID)>=5;

-- 27) DISPLAY THE DEPARTMENTS INTO WHICH NO EMPLOYEE JOINED IN LAST TWO YEARS.
SELECT * FROM NJCT_A_DEPARTMENTS
WHERE DEPARTMENT_ID NOT IN(SELECT DISTINCT DEPARTMENT_ID FROM NJCT_A_EMPLOYEES
WHERE (EXTRACT(YEAR FROM SYSDATE)-EXTRACT(YEAR FROM HIRE_DATE)) < 2);

-- 28) DISPLAY THE DETAILS OF DEPARTMENTS IN WHICH THE MAX SALARY IS GREATER THAN 10000 FOR EMPLOYEES WHO DID A JOB IN THE PAST.
SELECT DISTINCT D.* FROM NJCT_A_DEPARTMENTS D
JOIN NJCT_A_JOB_HISTORY JH ON JH.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN NJCT_A_JOBS J ON J.JOB_ID = JH.JOB_ID
WHERE J.MAX_SALARY >10000;

-- 29) DISPLAY THIRD HIGHEST SALARY OF ALL EMPLOYEES
SELECT MIN(SALARY) FROM (
SELECT SALARY FROM NJCT_A_EMPLOYEES 
WHERE SALARY IS NOT NULL 
ORDER BY SALARY DESC
) WHERE ROWNUM<=3;

/*##################################################################################################################*/

-- 1) FIND OUT THE NAME OF THE EMPLOYEE AND NAME OF THE DEPARTMENT FOR THE EMPLOYEE WHO IS MANAGING FOR EMPLOYEE 103.

DECLARE
    V_EID NJCT_A_EMPLOYEES.EMPLOYEE_ID%TYPE;
    V_FN NJCT_A_EMPLOYEES.FIRST_NAME%TYPE;
    V_DID NJCT_A_EMPLOYEES.DEPARTMENT_ID%TYPE;
    V_DN NJCT_A_DEPARTMENTS.DEPARTMENT_NAME%TYPE;
BEGIN
    V_EID := &V_EID;

    SELECT E.FIRST_NAME,E.DEPARTMENT_ID INTO V_FN,V_DID FROM NJCT_A_EMPLOYEES E
    JOIN NJCT_A_EMPLOYEES M ON E.EMPLOYEE_ID = M.MANAGER_ID
    WHERE M.EMPLOYEE_ID = V_EID;

    SELECT DEPARTMENT_NAME INTO V_DN FROM NJCT_A_DEPARTMENTS WHERE DEPARTMENT_ID = V_DID;

    DBMS_OUTPUT.PUT_LINE('MANAGER NAME :- '|| V_FN);
    DBMS_OUTPUT.PUT_LINE('DEPARTMENT NAME :- '|| V_DN);
END;

-- 2) DISPLAY THE YEAR IN WHICH MAXIMUM NUMBER OF EMPLOYEES JOINED ALONG WITH HOW MANY JOINED IN EACH MONTH IN THAT YEAR.
DECLARE
    V_MAX_COUNT NUMBER;
    V_YEAR NUMBER;
    V_MONTH NUMBER;
    V_COUNT NUMBER;

    CURSOR CURMAXYEAR(V_MAX NUMBER) IS SELECT EXTRACT(YEAR FROM HIRE_DATE) FROM NJCT_A_EMPLOYEES
    GROUP BY EXTRACT(YEAR FROM HIRE_DATE)
    HAVING COUNT(EXTRACT(YEAR FROM HIRE_DATE)) = V_MAX;

    CURSOR CURMONTHWISE(V_MONTH_YEAR NUMBER)
    IS SELECT EXTRACT(MONTH FROM HIRE_DATE),COUNT(EXTRACT(MONTH FROM HIRE_DATE)) FROM NJCT_A_EMPLOYEES
    WHERE EXTRACT(YEAR FROM HIRE_DATE) = V_MONTH_YEAR
    GROUP BY EXTRACT(MONTH FROM HIRE_DATE);
BEGIN

    SELECT MAX(COUNT(EXTRACT(YEAR FROM HIRE_DATE))) INTO V_MAX_COUNT  FROM NJCT_A_EMPLOYEES
    GROUP BY EXTRACT(YEAR FROM HIRE_DATE);

    OPEN CURMAXYEAR(V_MAX_COUNT);
    LOOP--OUTER LOOP
    FETCH CURMAXYEAR INTO V_YEAR;
    EXIT WHEN CURMAXYEAR%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('---------------------------------------');
        DBMS_OUTPUT.PUT_LINE('YEAR : '||V_YEAR ||' NO. OF EMPLOYEE JOINED : '||V_MAX_COUNT);
        DBMS_OUTPUT.PUT_LINE('---------------------------------------');

        OPEN CURMONTHWISE(V_YEAR);
        LOOP--INNER LOOP
        FETCH CURMONTHWISE INTO V_MONTH,V_COUNT;
        EXIT WHEN CURMONTHWISE%NOTFOUND;
            DBMS_OUTPUT.PUT_LINE('|-MONTH : '||TO_CHAR(TO_DATE(V_MONTH, 'MM'), 'MON')||' NO OF EMPLOYEE HIRED : '||V_COUNT);
        END LOOP;--END OF INNER LOOP
        CLOSE CURMONTHWISE;

    END LOOP;--END OF OUTER LOOP
    CLOSE CURMAXYEAR;

    EXCEPTION 
    WHEN INVALID_CURSOR THEN
        DBMS_OUTPUT.PUT_LINE('CURSOR IS INVALID, KINDLY CONTACT THE ADMINISTRATOR');
END;

-- 3) CHANGE SALARY OF EMPLOYEE 130 TO THE SALARY OF THE EMPLOYEE WITH FIRST NAME ‘JOE’. IF JOE IS
-- NOT FOUND THEN TAKE AVERAGE SALARY OF ALL EMPLOYEES. IF MORE THAN ONE EMPLOYEE WITH FIRST 
-- NAME ‘JOE’ IS FOUND THEN TAKE THE LEAST SALARY OF THE EMPLOYEES WITH FIRST NAME JOE. [USE
-- EXCEPTIONS]
/*
SALARY OF 130 TO THE FN->JOE
IF JOE IS NOTFOUND 
THEN 
SALARY OF 130 = AVG(SALARY)
ELSE IF MORE THAN ONE JOE IS FOUND THE MIN(SALARY OF JOE);
*/

--IN THIS CASE 103
DECLARE 
    V_SALARY NJCT_A_EMPLOYEES.SALARY%TYPE;
BEGIN
    SELECT SALARY INTO V_SALARY FROM NJCT_A_EMPLOYEES WHERE FIRST_NAME LIKE 'JOE';
    UPDATE NJCT_A_EMPLOYEES SET SALARY = V_SALARY WHERE EMPLOYEE_ID = 130;--103
    DBMS_OUTPUT.PUT_LINE('SALARY UPDATED SUCCESSFULLY');

    EXCEPTION
    WHEN NO_DATA_FOUND THEN
        SELECT AVG(SALARY) INTO V_SALARY FROM NJCT_A_EMPLOYEES;
        UPDATE NJCT_A_EMPLOYEES SET SALARY = V_SALARY WHERE EMPLOYEE_ID = 130;--103
        DBMS_OUTPUT.PUT_LINE('SALARY UPDATED SUCCESSFULLY');
    WHEN TOO_MANY_ROWS THEN
        SELECT MIN(SALARY) INTO V_SALARY FROM NJCT_A_EMPLOYEES WHERE FIRST_NAME LIKE 'JOE';
        UPDATE NJCT_A_EMPLOYEES SET SALARY = V_SALARY WHERE EMPLOYEE_ID = 130;--103
        DBMS_OUTPUT.PUT_LINE('SALARY UPDATED SUCCESSFULLY');
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('AN ERROR OCCURRED');
END;

-- 4) DISPLAY JOB TITLE AND NAME OF THE EMPLOYEE WHO JOINED THE JOB FIRST DAY. 

DECLARE
    V_FIRSTNAME NJCT_A_EMPLOYEES.FIRST_NAME%TYPE;
    V_JOB_TITLE NJCT_A_JOBS.JOB_TITLE%TYPE;
    V_COUNT NUMBER;

    CURSOR CUR_FIRST_DAY
    IS SELECT JOB_TITLE,FIRST_NAME FROM NJCT_A_JOBS J
    JOIN NJCT_A_EMPLOYEES E ON E.JOB_ID = J.JOB_ID
    WHERE TO_DATE(HIRE_DATE,'YYYY-MM-DD')-TO_DATE(SYSDATE,'YYYY-MM-DD')  = 0;
BEGIN
    SELECT COUNT(EMPLOYEE_ID) INTO V_COUNT FROM NJCT_A_EMPLOYEES WHERE TO_DATE(HIRE_DATE,'YYYY-MM-DD')-TO_DATE(SYSDATE,'YYYY-MM-DD')  = 0;

    IF V_COUNT > 0 THEN
        OPEN CUR_FIRST_DAY;
        LOOP
        FETCH CUR_FIRST_DAY INTO V_JOB_TITLE,V_FIRSTNAME;
        EXIT WHEN CUR_FIRST_DAY%NOTFOUND; 
        DBMS_OUTPUT.PUT_LINE('JOB : '||V_JOB_TITLE||' || EMPLOYEE NAME : '||V_FIRSTNAME);
        END LOOP;
        CLOSE CUR_FIRST_DAY;
    ELSE
        DBMS_OUTPUT.PUT_LINE('NO ONE HAVE FIRST DAY TODAY!!!');
    END IF;

    EXCEPTION
    WHEN INVALID_CURSOR THEN --INVALID_CURSOR
        DBMS_OUTPUT.PUT_LINE('INVALID CURSOR CHECK AGAIN!!');
END;

-- 5) ENSURE NO CHANGES CAN BE MADE TO EMPLOYEES TABLE BEFORE 6AM AND AFTER 10PM IN A DAY.

-- SELECT TO_CHAR(CURRENT_DATE, 'HH24') FROM DUAL; 

CREATE OR REPLACE TRIGGER NO_CHANGE_ON_NJCT_A_EMPLOYEES
BEFORE INSERT OR UPDATE OR DELETE ON NJCT_A_EMPLOYEES
FOR EACH ROW
DECLARE
    V_TIME NUMBER;
BEGIN
    SELECT TO_CHAR(CURRENT_DATE, 'HH24') INTO V_TIME FROM DUAL;

    IF (V_TIME > 6 AND V_TIME < 22) THEN
        RAISE_APPLICATION_ERROR(-20101, 'DML ALLOW BETWEEN 6AM AND 10PM');
    ELSE
        DBMS_OUTPUT.PUT_LINE('DML DONE SUCCESSFULLY!');
    END IF;
END;

-- 6) WHENEVER THE JOB IS CHANGED FOR AN EMPLOYEE WRITE THE FOLLOWING DETAILS INTO JOB HISTORY.
-- EMPLOYEE ID, OLD JOB ID, OLD DEPARTMENT ID, HIRE DATE OF THE EMPLOYEE FOR START DATE, SYSTEM
-- DATE FOR END DATE. BUT IF A ROW IS ALREADY PRESENT FOR EMPLOYEE JOB HISTORY THEN THE START DATE
-- SHOULD BE THE END DATE OF THAT ROW +1.

CREATE OR REPLACE TRIGGER TRIGGER_NJCT_A_JOB_HISTORY
AFTER UPDATE OF JOB_ID
ON NJCT_A_EMPLOYEES
FOR EACH ROW
DECLARE
    CURSOR CUR_OF_EMP_FOR_JH--JH:=JOB_HISTORY
    IS 
    SELECT MAX(END_DATE) FROM NJCT_A_JOB_HISTORY WHERE EMPLOYEE_ID=:OLD.EMPLOYEE_ID;

    V_COUNT NUMBER;
    V_DATE DATE;
BEGIN
    SELECT COUNT(EMPLOYEE_ID) INTO V_COUNT FROM NJCT_A_JOB_HISTORY WHERE EMPLOYEE_ID = :OLD.EMPLOYEE_ID;
    --ABOVE LINE CHECKS IF USER ALREADY IN JOB_HISTORY TABLE
    --IF COUNT > 0 THAT MEAN USER IS ALREADY IN JOB_HISTORY ELSE HE/SHE IS CHANGING THE JOB FOR THE 1ST TIME 
    IF (V_COUNT > 0) THEN--USER IS ALREADY IN JOB_HISTORY
        OPEN CUR_OF_EMP_FOR_JH;
        FETCH CUR_OF_EMP_FOR_JH INTO V_DATE; 
        INSERT INTO NJCT_A_JOB_HISTORY 
        VALUES (:OLD.EMPLOYEE_ID,V_DATE + 1,SYSDATE,:OLD.JOB_ID,:OLD.DEPARTMENT_ID);  
                                --END_DATE + 1
        CLOSE CUR_OF_EMP_FOR_JH;
        --DBMS_OUTPUT.PUT_LINE('IF PART EXECUTED');      
    ELSE--USER IS NOT IN JOB_HISTORY
        INSERT INTO NJCT_A_JOB_HISTORY 
        VALUES (:OLD.EMPLOYEE_ID,:OLD.HIRE_DATE,SYSDATE,:OLD.JOB_ID,:OLD.DEPARTMENT_ID);
                                --HIRE_DATE
        --DBMS_OUTPUT.PUT_LINE('ELSE PART EXECUTED');
    END IF;
END;

/*##################################################################################################################*/

-- Below PL/SQL Program are not related to the schema provided in this Assignment set above.

-- 7) What output is displayed when the following PL/SQL block is executed? Kindly don't execute
-- the code directly and try to figure it out on your own. Also explain why this output will occur. Also
-- explain each and every new term which is used here and we haven't discuss in the class. Please
-- note, Assignment will not be graded, if you fail to explain the code. [ 25 Points ]

DECLARE
    CURSOR no_data
    IS
    SELECT dummy FROM DUAL WHERE 1 = 2; --WILL FETCH NOTHING SO CURSOR IS EMPTY

    var VARCHAR2 (1); -- VARIABLE OF VARCHAR2 OF SIZE 1

    TYPE tabtype IS TABLE OF no_data%ROWTYPE --COLLECTION i.e, ARRAY OF TYPE CURSOR%ROWTYPE WHICH WE DECLARE ABOVE
                            INDEX BY BINARY_INTEGER;
    --LIKE A CLASS
    tab tabtype; --VARIABLE OF TYPE ARRAY/COLLECTION WHICH WE DECLARE ABOVE
    --LIKE A OBJECT OF A CLASS
BEGIN
    var := 'Z';--ASSIGN 'Z' TO VAR
    
    OPEN no_data; --OPEN CURSOR
    FETCH no_data INTO var; -- FETCH DATA INTO VAR
    --AS CURSOR IS EMPTY VAR NOT AFFECTED
    CLOSE no_data; -- CLOSE CURSOR

    DBMS_OUTPUT.put_line (NVL (var, 'null')); --WILL DISPLAY'S   'Z'  AS OUTPUT
    --NVL() IS FUNCTION THAT CHECK IF VARIABLE/OBJECT IS NULL THEN IT REPLACE WITH IT'S REPLACEMENT-OBJECT

    tab (1).dummy := 'Z'; --1ST ARRAY ELEMENT OF ARRAY i.e, ARRAY[0] 
    --INDEX STARTS WITH 1
    --AS WE DECLARE ARRAY OF CURSOR%ROWTYPE WE ASSIGN THE VALUE THROUGH SPECIFIC COLUMN
    -- ARRAY(1).COLUMNNAME := VALUE;

    OPEN no_data; --OPEN CURSOR
    FETCH no_data BULK COLLECT INTO tab; --FETCH DATA INTO THE ARRAY
    CLOSE no_data; --CLOSE CURSOR

    -- AS CURSOR HAVE NO DATA ARRAY WILL NOT FOUND ANYDATA SO IT'LL THROUGH AN EXCEPTION NO_DATA_FOUND
    DBMS_OUTPUT.put_line (tab (1).dummy); -- EXCEPTION 
    --ASA WE DISPALY THE ARRAY ELEMENT IT'LL THROW AN EXCEPTION

    EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.put_line ('NDF');
END;

-- 8) What happens when a table on which Procedure is based on is deleted or changed? Explain your answer and also,
-- how to rectify it

=>> AS TRIGGER OR PROCEDURE ARE ALREADY CREATED 
    IF WE DROP THE TABLE ON WHICH THE TRIGGER/PROCEDURE IS CREATED
    ASA WE CALL THE PROCEDURE OR TRIGGER GET EXCECUTED 
    IT WILL THROUGH AN EXCEPTION THAT OBJECT NOT FOUND
    ORA-00942: table or view does not exist

=>> ORA-06550: line 1, column 7:
    PLS-00905: object SQL_VCVMOXDQGPEJWJWMYLAJRUIDP.[PROCEDURE_NAME] is invalid

-- 9)-----------------------------------------------

-- 9.1) What will be the output when the above procedure is executed, also explain it – step by step?

CREATE OR REPLACE PROCEDURE Discount
AS
    CURSOR c_group_discount
    IS
    SELECT DISTINCT s.course_no,c.description FROM section s,enrollment e,course c -- JOIN SECTION,ENROLLMENT,COURSE TABLE
    WHERE s.section_id = e.section_id AND c.course_no = s.course_no -- CONDITION FOR JOIN 
    GROUP BY s.course_no,c.description,e.section_id,s.section_id -- GROUP BY COURSE_NO
    HAVING COUNT(*) >=8; --ENROLLED BY MORE THAN 8 IN PARTICULAR COURSE
    --THE ABOVE CURSOR WILL FETCHES THE RECORD THAT THE ENROLLMENT TAKEN IN COURSE IS MORE THAN 8
BEGIN
    FOR r_group_discount IN c_group_discount
    --CURSOR FOR LOOP
    LOOP
        UPDATE course SET cost = cost * .95 --DISCOUNT
        WHERE course_no = r_group_discount.course_no;
        --WILL GET UPDATE WHICH COURSE IS VERY DEMANDING "ACCORDING TO THE CONDITION COUNT(*) >= 8"
        DBMS_OUTPUT.PUT_LINE ('A 5% discount has been given to '||r_group_discount.course_no||' '|| r_group_discount.description );
    END LOOP;
END;


-- 9.2) The script does not contain a COMMIT.
-- Discuss the issues involved with placing a COMMIT in the procedure, and indicate where the COMMIT could be placed.

    WE CAN PLACE COMMIT/ROLLBACK IN SCRIPT PROCEDURE HAS NO PROLEM WITH IT
    BUT IT'S NOT GOOD TO PLACE COMMITE/ROLLBACK IN SCRIPT
    BECAUSE IF YOUR PROCEDURE GOT AN EXCEPTION THAN THE PLACED COMMIT WILL DO NOTHING
    IF 50% DATA IS PROCESSED IN TABLE BUT YOU GOT THE EXCEPTION AT OTHER 50% THEN YOUR 50% DATA IS COMMITED ALREADY 
    AND YOU'LL NOT GET THE DESIRE OUTPUT

    GOOD PRACTISE
        BEGIN
            PROCEDURE_NAME;
            COMMIT/ROLLBACK;
        END;

    RATHER THAN PLACING COMMIT/ROLLBACK IN MAIN PROCEDURE WE CAN PLACE COMMIT IN PL/SQL(UN NAMED) BLOCK

-- 9.3) Write a SELECT statement to display the source code for the Discount procedure

    SELECT Text FROM User_Source WHERE Name ='FNX_WEEK_DAY_NJCT_A_TRIAL' ORDER BY Line;

    SELECT TEXT FROM USER_SOURCE WHERE NAME = 'OBJECT_NAME';-- ORDER BY LINE;

-- 10)Write a procedure with no parameters.The procedure should say whether the current day is a
-- weekend or weekday. Additionally, it should tell you the user’s name and the current time. It also
-- should specify how many valid and invalid procedures are in the database.

CREATE OR REPLACE PROCEDURE NJCT_PROC_WEEK_OR_WEEKEND_DAY
AS
    V_DAY NUMBER;
    V_VALID NUMBER;
    V_INVALID NUMBER;
    V_PROC NUMBER;
BEGIN
    SELECT TO_CHAR(SYSDATE,'D') INTO V_DAY FROM DUAL;
    SELECT COUNT(STATUS) INTO V_PROC FROM DBA_OBJECTS WHERE OBJECT_TYPE = 'PROCEDURE';
    SELECT COUNT(STATUS) INTO V_VALID FROM DBA_OBJECTS WHERE OBJECT_TYPE = 'PROCEDURE' AND STATUS = 'VALID';
    SELECT COUNT(STATUS) INTO V_INVALID FROM DBA_OBJECTS WHERE OBJECT_TYPE = 'PROCEDURE' AND STATUS = 'INVALID';

        DBMS_OUTPUT.PUT_LINE('------------------------------------');
    --DBMS_OUTPUT.PUT_LINE(V_DAY);
    IF (V_DAY = 1 OR V_DAY = 7) THEN--i.e, 1:=SUNDAY OR 7:=SATURDAY
        DBMS_OUTPUT.PUT_LINE('TODAY IS WEEKEND, ENJOY!!');
    ELSE
        DBMS_OUTPUT.PUT_LINE('TODAY IS WEEK DAY, GET BACK TO WORK!!');
    END IF;
        DBMS_OUTPUT.PUT_LINE('------------------------------------');

--    SELECT TO_CHAR(CURRENT_TIMESTAMP,'HH24:MI:SS') FROM DUAL;
    DBMS_OUTPUT.PUT_LINE('                    USER : '||USER);
    DBMS_OUTPUT.PUT_LINE('                    TIME : '||TO_CHAR(CURRENT_TIMESTAMP,'HH24:MI:SS') );
    DBMS_OUTPUT.PUT_LINE('        NO. OF PROCEDURE : '||V_PROC);
    DBMS_OUTPUT.PUT_LINE('  NO. OF VALID PROCEDURE : '||V_VALID);
    DBMS_OUTPUT.PUT_LINE('NO. OF INVALID PROCEDURE : '||V_INVALID);
END;

EXEC NJCT_PROC_WEEK_OR_WEEKEND_DAY;

/*##################################################################################################################*/
/*##################################################################################################################*/
-- CREATE A FUNCTION THAT WILL NO. OF WORKING DAYS BETWEEN TEO DATES

CREATE OR REPLACE FUNCTION FNX_WEEK_DAY_NJCT_A_TRIAL(START_DATE DATE,LAST_DATE DATE)
--TAKE TWO DATES AS ARGUMENT
RETURN NUMBER
IS
    V_DATE DATE;
    V_COUNT NUMBER;
BEGIN

    IF (START_DATE < LAST_DATE) THEN -- CHECKS THE ORDER OF DATE
        V_DATE := START_DATE;
        V_COUNT := 0;
        LOOP
            IF(TO_CHAR(V_DATE,'D') != 1) THEN --IF DAY IS NOT SUNDAY THEN COUNT++
                V_COUNT := V_COUNT + 1;
            END IF;
            
            V_DATE := (V_DATE + 1);--DATE++
            EXIT WHEN V_DATE = LAST_DATE;--EXIT WHEN VARIABLE_DATE = END_DATE
        END LOOP;
        RETURN V_COUNT; --RETURNS NO.OF DAYS
    ELSE
        RETURN -1; --ERROR FLAG -1 IF START_DATE GRATER THAN END_DATE
    END IF;
END;

SELECT FNX_WEEK_DAY_NJCT_A_TRIAL('10-02-21','10-03-21') FROM DUAL;
SELECT FNX_WEEK_DAY_NJCT_A_TRIAL(TO_DATE(SYSDATE),'10-MAR-21') FROM DUAL;

/*##################################################################################################################*/
/*##################################################################################################################*/
/*##################################################################################################################*/
--MAX SALARY NULL SALARY
create table employee(empid number primary key,salary number,depid number);

insert into employee values(1,100,1);
insert into employee values(2,200,2);
insert into employee values(3,100,1);
insert into employee values(4,250,2);
insert into employee values(5,100,1);
insert into employee values(6,300,2);
insert into employee values(7,100,1);
insert into employee values(8,350,2);
insert into employee values(9,100,1);

-- update employee set depid = 2 where empid in (2,4);
select * from employee;
EMPID	SALARY	DEPID
3   	100 	1
5   	100 	1
9   	100 	1
1   	100 	1
7   	100 	1
8   	350 	2
2   	200 	2
4   	250 	2
6   	300 	2

-- select * from employee order by depid;

-- select empid,salary,depid,
--   case when salary = max(salary) then 0
--   else 1
-- end as maxsal
-- from employee
--where salary is not null
-- group by depid,salary,empid;
select empid,e.salary,t.msal,e.depid,
case when e.salary = t.msal then 1 --COMPARE WITH THE INNER QUERY IF TURE THEN 1
else 0  --ELSE O
end as counter --NAME OF COLUMN i.e, "COUNTER"
from employee e --THIS WILL BRINGS COUNTER 1 FOR EQUAL TO MAX SAL AND 0 FOR ><
join (select max(salary) msal,depid from employee group by depid) t --THIS WILL BRINGS THE MAX SALARY
on t.depid = e.depid
/************************/
EMPID	SALARY	MSAL	DEPID	COUNTER
3   	100 	100 	1   	1
5   	100 	100 	1   	1
9   	100 	100 	1   	1
1   	100 	100 	1   	1
7   	100 	100 	1   	1
2   	200 	350 	2   	0
8   	350 	350 	2   	1
4   	250 	350 	2   	0
6   	300 	350 	2   	0
/************************/

-- select max(salary) from employee group by depid;



select depid,sum(counter),--SUM OF COUNTER FOR DESIRE CONDITION
case when sum(counter)<=1 then max(salary) --WILL CHECKS FOR THE DESIRE REQUIREMENT
else NULL--i.e, MAX SAL IF NO ONE HAVE EUAL SALARY ELSE NULL
end as MAXSAL -- NAME OF COL
from 
(
select e.salary,e.depid,
case when e.salary = t.msal then 1 --COMPARE WITH THE INNER QUERY IF TURE THEN 1
else 0  --ELSE O
end as counter --NAME OF COLUMN i.e, "COUNTER"
from employee e --THIS WILL BRINGS COUNTER 1 FOR EQUAL TO MAX SAL AND 0 FOR ><
join (select max(salary) msal,depid from employee group by depid) t --THIS WILL BRINGS THE MAX SALARY
on t.depid = e.depid
) group by DEPID --OUTER QUERY GROUP BY DEPARTMENT_ID


/*
select 
case when sum(sal)<=1 then msal
else NULL
end as MAXSAL
from 
(
select empid,e.salary,t.msal,e.depid,
case when e.salary = t.msal then 1
else 0
end as sal
from employee e
join (select max(salary) msal,depid from employee group by depid) t
on t.depid = e.depid
)
*/

-- 1) FIND OUT THE NAME OF THE EMPLOYEE AND NAME OF THE DEPARTMENT FOR THE EMPLOYEE WHO IS
MANAGING FOR EMPLOYEE 103.

DECLARE

V_EID NJCT_A_EMPLOYEES.EMPLOYEE_ID%TYPE;
V_FN NJCT_A_EMPLOYEES.FIRST_NAME%TYPE;
V_DID NJCT_A_EMPLOYEES.DEPARTMENT_ID%TYPE;
V_DN NJCT_A_DEPARTMENTS.DEPARTMENT_NAME%TYPE;

BEGIN

V_EID := &V_EID;

SELECT E.FIRST_NAME,E.DEPARTMENT_ID INTO V_FN,V_DID FROM NJCT_A_EMPLOYEES E
JOIN NJCT_A_EMPLOYEES M ON E.EMPLOYEE_ID = M.MANAGER_ID
WHERE M.EMPLOYEE_ID = V_EID;

SELECT DEPARTMENT_NAME INTO V_DN FROM NJCT_A_DEPARTMENTS WHERE DEPARTMENT_ID = V_DID;

DBMS_OUTPUT.PUT_LINE('MANAGER NAME :- '|| V_FN);
DBMS_OUTPUT.PUT_LINE('DEPARTMENT NAME :- '|| V_DN);

END;


-- 2) DISPLAY THE YEAR IN WHICH MAXIMUM NUMBER OF EMPLOYEES JOINED ALONG WITH HOW MANY JOINED IN EACH MONTH IN THAT YEAR.
DECLARE
V_MAX_COUNT NUMBER;
V_YEAR NUMBER;
V_MONTH NUMBER;
V_COUNT NUMBER;

CURSOR CURMAXYEAR(V_MAX NUMBER) IS SELECT EXTRACT(YEAR FROM HIRE_DATE) FROM NJCT_A_EMPLOYEES
GROUP BY EXTRACT(YEAR FROM HIRE_DATE)
HAVING COUNT(EXTRACT(YEAR FROM HIRE_DATE)) = V_MAX;

CURSOR CURMONTHWISE(V_MONTH_YEAR NUMBER)
IS SELECT EXTRACT(MONTH FROM HIRE_DATE),COUNT(EXTRACT(MONTH FROM HIRE_DATE)) FROM NJCT_A_EMPLOYEES
WHERE EXTRACT(YEAR FROM HIRE_DATE) = V_MONTH_YEAR
GROUP BY EXTRACT(MONTH FROM HIRE_DATE);

BEGIN

SELECT MAX(COUNT(EXTRACT(YEAR FROM HIRE_DATE))) INTO V_MAX_COUNT  FROM NJCT_A_EMPLOYEES
GROUP BY EXTRACT(YEAR FROM HIRE_DATE);

OPEN CURMAXYEAR(V_MAX_COUNT);
LOOP--OUTER LOOP
FETCH CURMAXYEAR INTO V_YEAR;
EXIT WHEN CURMAXYEAR%NOTFOUND;
DBMS_OUTPUT.PUT_LINE('---------------------------------------');
DBMS_OUTPUT.PUT_LINE('YEAR : '||V_YEAR ||' NO. OF EMPLOYEE JOINED : '||V_MAX_COUNT);
DBMS_OUTPUT.PUT_LINE('---------------------------------------');

OPEN CURMONTHWISE(V_YEAR);
LOOP--INNER LOOP
FETCH CURMONTHWISE INTO V_MONTH,V_COUNT;
EXIT WHEN CURMONTHWISE%NOTFOUND;
DBMS_OUTPUT.PUT_LINE('|-MONTH : '||TO_CHAR(TO_DATE(V_MONTH, 'MM'), 'MON')||' NO OF EMPLOYEE HIRED : '||V_COUNT);
END LOOP;--END OF INNER LOOP
CLOSE CURMONTHWISE;

END LOOP;--END OF OUTER LOOP
CLOSE CURMAXYEAR;

EXCEPTION 
WHEN INVALID_CURSOR THEN
DBMS_OUTPUT.PUT_LINE('CURSOR IS INVALID, KINDLY CONTACT THE ADMINISTRATOR');
END;

-- DECLARE
-- V_MAX_COUNT NUMBER;
-- V_YEAR NUMBER;
-- V_MONTH NUMBER;
-- V_COUNT NUMBER;

-- CURSOR CURMONTHWISE(V_MONTH_YEAR NUMBER)
-- IS SELECT EXTRACT(MONTH FROM HIRE_DATE),COUNT(EXTRACT(MONTH FROM HIRE_DATE)) FROM NJCT_A_EMPLOYEES
-- WHERE EXTRACT(YEAR FROM HIRE_DATE) = V_MONTH_YEAR
-- GROUP BY EXTRACT(MONTH FROM HIRE_DATE);

-- BEGIN

-- SELECT MAX(COUNT(EXTRACT(YEAR FROM HIRE_DATE))) INTO V_MAX_COUNT FROM NJCT_A_EMPLOYEES
-- GROUP BY EXTRACT(YEAR FROM HIRE_DATE);

-- SELECT EXTRACT(YEAR FROM HIRE_DATE) INTO V_YEAR FROM NJCT_A_EMPLOYEES
-- GROUP BY EXTRACT(YEAR FROM HIRE_DATE)
-- HAVING COUNT(EXTRACT(YEAR FROM HIRE_DATE)) = V_MAX_COUNT;

-- DBMS_OUTPUT.PUT_LINE('YEAR : '||V_YEAR);
-- DBMS_OUTPUT.PUT_LINE('NO. OF EMPLOYEE JOINED : '||V_MAX_COUNT);

-- OPEN CURMONTHWISE(V_YEAR);
-- LOOP
-- FETCH CURMONTHWISE INTO V_MONTH,V_COUNT;

-- DBMS_OUTPUT.PUT_LINE('MONTH : '||V_MONTH||' NO OF EMPLOYEE HIRED : '||V_COUNT);

-- EXIT WHEN CURMONTHWISE%NOTFOUND;
-- END LOOP;

-- CLOSE CURMONTHWISE;
-- EXCEPTION 
-- WHEN INVALID_CURSOR THEN
-- DBMS_OUTPUT.PUT_LINE('CURSOR IS INVALID, KINDLY CONTACT THE ADMINISTRATOR');
-- END;

-- 3) CHANGE SALARY OF EMPLOYEE 130 TO THE SALARY OF THE EMPLOYEE WITH FIRST NAME ‘JOE’. IF JOE IS
-- NOT FOUND THEN TAKE AVERAGE SALARY OF ALL EMPLOYEES. IF MORE THAN ONE EMPLOYEE WITH FIRST 
-- NAME ‘JOE’ IS FOUND THEN TAKE THE LEAST SALARY OF THE EMPLOYEES WITH FIRST NAME JOE. [USE
-- EXCEPTIONS]
/*
SALARY OF 130 TO THE FN->JOE
IF JOE IS NOTFOUND 
THEN 
SALARY OF 130 = AVG(SALARY)
ELSE IF MORE THAN ONE JOE IS FOUND THE MIN(SALARY OF JOE);
*/
DECLARE 

V_SALARY NJCT_A_EMPLOYEES.SALARY%TYPE;

BEGIN

SELECT SALARY INTO V_SALARY FROM NJCT_A_EMPLOYEES WHERE FIRST_NAME LIKE 'JOE';
UPDATE NJCT_A_EMPLOYEES SET SALARY = V_SALARY WHERE EMPLOYEE_ID = 130;
DBMS_OUTPUT.PUT_LINE('SALARY UPDATED SUCCESSFULLY');

EXCEPTION
WHEN NO_DATA_FOUND THEN
  SELECT AVG(SALARY) INTO V_SALARY FROM NJCT_A_EMPLOYEES;
  UPDATE NJCT_A_EMPLOYEES SET SALARY = V_SALARY WHERE EMPLOYEE_ID = 130;
  DBMS_OUTPUT.PUT_LINE('SALARY UPDATED SUCCESSFULLY');
WHEN TOO_MANY_ROWS THEN
  SELECT MIN(SALARY) INTO V_SALARY FROM NJCT_A_EMPLOYEES WHERE FIRST_NAME LIKE 'JOE';
  UPDATE NJCT_A_EMPLOYEES SET SALARY = V_SALARY WHERE EMPLOYEE_ID = 130;
  DBMS_OUTPUT.PUT_LINE('SALARY UPDATED SUCCESSFULLY');
WHEN OTHERS THEN
  DBMS_OUTPUT.PUT_LINE('AN ERROR OCCURRED');

END;
/*
SELECT EMPLOYEE_ID,FIRST_NAME,SALARY FROM NJCT_A_EMPLOYEES ORDER BY FIRST_NAME;

SELECT MIN(SALARY) FROM NJCT_A_EMPLOYEES WHERE FIRST_NAME LIKE 'C'
GROUP BY FIRST_NAME ;S
*/

-- 4) DISPLAY JOB TITLE AND NAME OF THE EMPLOYEE WHO JOINED THE JOB FIRST DAY. 

DECLARE
V_FIRSTNAME NJCT_A_EMPLOYEES.FIRST_NAME%TYPE;
V_JOB_TITLE NJCT_A_JOBS.JOB_TITLE%TYPE;
V_COUNT NUMBER;

CURSOR CUR_FIRST_DAY
IS SELECT JOB_TITLE,FIRST_NAME FROM NJCT_A_JOBS J
JOIN NJCT_A_EMPLOYEES E ON E.JOB_ID = J.JOB_ID
WHERE TO_DATE(HIRE_DATE,'YYYY-MM-DD')-TO_DATE(SYSDATE,'YYYY-MM-DD')  = 0;

BEGIN

SELECT COUNT(EMPLOYEE_ID) INTO V_COUNT FROM NJCT_A_EMPLOYEES WHERE TO_DATE(HIRE_DATE,'YYYY-MM-DD')-TO_DATE(SYSDATE,'YYYY-MM-DD')  = 0;

IF V_COUNT > 0 THEN
OPEN CUR_FIRST_DAY;

LOOP
FETCH CUR_FIRST_DAY INTO V_JOB_TITLE,V_FIRSTNAME;
EXIT WHEN CUR_FIRST_DAY%NOTFOUND; 
DBMS_OUTPUT.PUT_LINE('JOB : '||V_JOB_TITLE||' || EMPLOYEE NAME : '||V_FIRSTNAME);
END LOOP;

CLOSE CUR_FIRST_DAY;
ELSE
DBMS_OUTPUT.PUT_LINE('NO ONE HAVE FIRST DAY TODAY!!!');
END IF;

EXCEPTION
WHEN INVALID_CURSOR THEN --INVALID_CURSOR
DBMS_OUTPUT.PUT_LINE('INVALID CURSOR CHECK AGAIN!!');
END;
/*
SELECT JOB_TITLE,FIRST_NAME FROM NJCT_A_JOBS J
JOIN NJCT_A_EMPLOYEES E ON E.JOB_ID = J.JOB_ID
WHERE TO_DATE(HIRE_DATE,'YYYY-MM-DD')-TO_DATE(SYSDATE,'YYYY-MM-DD')  = 0;
*/
-- DECLARE
-- V_FIRSTNAME NJCT_A_EMPLOYEES.FIRST_NAME%TYPE;
-- V_JOB_TITLE NJCT_A_JOBS.JOB_TITLE%TYPE;

-- CURSOR CUR_FIRST_DAY
-- IS SELECT JOB_TITLE,FIRST_NAME FROM NJCT_A_JOBS J
-- JOIN NJCT_A_EMPLOYEES E ON E.JOB_ID = J.JOB_ID
-- WHERE TO_DATE(HIRE_DATE,'YYYY-MM-DD')-TO_DATE(SYSDATE,'YYYY-MM-DD')  = 0;

-- BEGIN

-- OPEN CUR_FIRST_DAY;

-- IF CUR_FIRST_DAY%ROWCOUNT = 0 THEN
-- DBMS_OUTPUT.PUT_LINE('NO ONE HAVE FIRST DAY TODAY!!!');
-- ELSE 
-- LOOP
-- FETCH CUR_FIRST_DAY INTO V_JOB_TITLE,V_FIRSTNAME;
-- EXIT WHEN CUR_FIRST_DAY%NOTFOUND;
-- DBMS_OUTPUT.PUT_LINE('JOB : '||V_JOB_TITLE||' EMPLOYEE NAME :'||V_FIRSTNAME);
-- END LOOP;
-- END IF;

-- CLOSE CUR_FIRST_DAY;

-- EXCEPTION
-- WHEN INVALID_CURSOR THEN --INVALID_CURSOR
-- DBMS_OUTPUT.PUT_LINE('INVALID CURSOR CHECK AGAIN!!');
-- END;

/*
OPEN CUR_FIRST_DAY;
LOOP
FETCH CUR_FIRST_DAY INTO V_JOB_TITLE,V_FIRSTNAME;
EXIT WHEN CUR_FIRST_DAY%NOTFOUND;
DBMS_OUTPUT.PUT_LINE('JOB : '||V_JOB_TITLE||' EMPLOYEE NAME :'||V_FIRSTNAME);
END LOOP;
CLOSE CUR_FIRST_DAY;
EXCEPTION
WHEN NO_DATA_FOUND THEN --INVALID_CURSOR
DBMS_OUTPUT.PUT_LINE('NO ONE HAVE FIRST DAY TODAY!!!');
*/

/*
SELECT * FROM NJCT_A_EMPLOYEES;
UPDATE NJCT_A_EMPLOYEES SET HIRE_DATE = '19-12-20' WHERE EMPLOYEE_ID =117;


OPEN CUR_FIRST_DAY;

IF CUR_FIRST_DAY%NOTFOUND THEN
DBMS_OUTPUT.PUT_LINE('NO ONE HAVE FIRST DAY TODAY!!!');
ELSE 
LOOP
FETCH CUR_FIRST_DAY INTO V_JOB_TITLE,V_FIRSTNAME;
EXIT WHEN CUR_FIRST_DAY%NOTFOUND;
DBMS_OUTPUT.PUT_LINE('JOB : '||V_JOB_TITLE||' EMPLOYEE NAME :'||V_FIRSTNAME);
END LOOP;
END IF;

CLOSE CUR_FIRST_DAY;

EXCEPTION
WHEN INVALID_CURSOR THEN --INVALID_CURSOR
DBMS_OUTPUT.PUT_LINE('INVALID CURSOR CHECK AGAIN!!');

*/

-- 5) ENSURE NO CHANGES CAN BE MADE TO EMPLOYEES TABLE BEFORE 6AM AND AFTER 10PM IN A DAY.

SELECT TO_CHAR(CURRENT_DATE, 'HH24') FROM DUAL; 
/*
CREATE OR REPLACE TRIGGER TRG_SUNDAY
BEFORE INSERT ON EMPLOYEE
REFERENCING NEW AS NEW OLD AS OLD
FOR EACH ROW
BEGIN
    IF TO_CHAR(SYSDATE, 'D') = '1' THEN   ---SHOULD BE 1 RATHER THAN 7
        RAISE_APPLICATION_ERROR(-20000, 'CANNOT INSERT RECORD ON SUNDAY'); 
    END IF;
END;

FOR SUNDAY
*/
CREATE OR REPLACE TRIGGER NO_CHANGE_ON_NJCT_A_EMPLOYEES
BEFORE INSERT OR UPDATE OR DELETE ON NJCT_A_EMPLOYEES
FOR EACH ROW
DECLARE
V_TIME NUMBER;
BEGIN

SELECT TO_CHAR(CURRENT_DATE, 'HH24') INTO V_TIME FROM DUAL;

IF (V_TIME > 6 AND V_TIME < 22) THEN
RAISE_APPLICATION_ERROR(-20101, 'DML ALLOW BETWEEN 6AM AND 10PM');
ELSE
DBMS_OUTPUT.PUT_LINE('DML DONE SUCCESSFULLY!');
END IF;

END;
/*
CREATE OR REPLACE TRIGGER NO_CHANGE_ON_NJCT_A_EMPLOYEES
BEFORE INSERT OR UPDATE OR DELETE ON NJCT_A_EMPLOYEES
FOR EACH ROW
DECLARE
V_TIME NUMBER;
E_TIME EXCEPTION;
BEGIN

SELECT TO_CHAR(CURRENT_DATE, 'HH24') INTO V_TIME FROM DUAL;

IF (V_TIME > 6 AND V_TIME < 22) THEN
RAISE E_TIME;
ELSE
DBMS_OUTPUT.PUT_LINE('DML IS ALLOW THIS TIME!!!!');
END IF;

EXCEPTION
WHEN E_TIME THEN
DBMS_OUTPUT.PUT_LINE('DML IS NOT ALLOW THIS TIME!!!!');

END;

*/

-- 6) WHENEVER THE JOB IS CHANGED FOR AN EMPLOYEE WRITE THE FOLLOWING DETAILS INTO JOB HISTORY.
-- EMPLOYEE ID, OLD JOB ID, OLD DEPARTMENT ID, HIRE DATE OF THE EMPLOYEE FOR START DATE, SYSTEM
-- DATE FOR END DATE. BUT IF A ROW IS ALREADY PRESENT FOR EMPLOYEE JOB HISTORY THEN THE START DATE
-- SHOULD BE THE END DATE OF THAT ROW +1.

CREATE OR REPLACE TRIGGER TRIGGER_NJCT_A_JOB_HISTORY
AFTER UPDATE OF JOB_ID
ON NJCT_A_EMPLOYEES
FOR EACH ROW
DECLARE
CURSOR CURTRIAL
IS
SELECT MAX(END_DATE) FROM NJCT_A_JOB_HISTORY WHERE EMPLOYEE_ID=:OLD.EMPLOYEE_ID;

V_COUNT NUMBER;
V_DATE DATE;

BEGIN

SELECT COUNT(EMPLOYEE_ID) INTO V_COUNT FROM NJCT_A_JOB_HISTORY WHERE EMPLOYEE_ID = :OLD.EMPLOYEE_ID;

IF (V_COUNT > 0) THEN
OPEN CURTRIAL;
FETCH CURTRIAL INTO V_DATE;

INSERT INTO NJCT_A_JOB_HISTORY 
VALUES (:OLD.EMPLOYEE_ID,V_DATE + 1,SYSDATE,:OLD.JOB_ID,:OLD.DEPARTMENT_ID);

CLOSE CURTRIAL;
DBMS_OUTPUT.PUT_LINE('IF');

ELSE
INSERT INTO NJCT_A_JOB_HISTORY 
VALUES (:OLD.EMPLOYEE_ID,:OLD.HIRE_DATE,SYSDATE,:OLD.JOB_ID,:OLD.DEPARTMENT_ID);

DBMS_OUTPUT.PUT_LINE('ELSE');
END IF;

END;
/*
CREATE OR REPLACE TRIGGER TRIGGER_JOB_HISTORY
AFTER UPDATE OF JOB_ID
ON NJCT_A_EMPLOYEES
FOR EACH ROW
BEGIN

INSERT INTO NJCT_A_JOB_HISTORY 
VALUES (:OLD.EMPLOYEE_ID,:OLD.HIRE_DATE,SYSDATE,:OLD.JOB_ID,:OLD.DEPARTMENT_ID);

END;

IF(EMPLOYEE_ID IS THERE IN NJCT_A_JOB_HISTORY) THEN
START_DATE = END_DATE + 1;
END_DATE = SYSDATE;
ELSE
INSERT INTO NJCT_A_JOB_HISTORY 
VALUES (:OLD.EMPLOYEE_ID,:OLD.HIRE_DATE,SYSDATE,:OLD.JOB_ID,:OLD.DEPARTMENT_ID);
END I0F;
*/
/*0000000000000000000*/
        /*FALSE TRIGGER WITH ERROR*/
        Errors: TRIGGER TRIGGER_JOB_HISTORY
        Line/Col: 8/1 PL/SQL: SQL Statement ignored
        Line/Col: 8/45 PL/SQL: ORA-00942: table or view does not exist
-- CREATE OR REPLACE TRIGGER TRIGGER_JOB_HISTORY
-- AFTER UPDATE OF JOB_ID
-- ON NJCT_A_EMPLOYEES
-- FOR EACH ROW
-- DECLARE
-- V_COUNT NUMBER;
-- V_DATE DATE;--V_EMPLOYEE_ID NJCT_A_JOB_HISTORY.EMPLOYEE_ID%TYPE;
-- CURSOR CURTRIAL(V_EMPLOYEE_ID NUMBER) IS 
-- SELECT END_DATE FROM (SELECT END_DATE FROM NJCT_A_JOB_HISTORY WHERE EMPLOYEE_ID = V_EMPLOYEE_ID ORDER BY END_DATE DESC) WHERE ROWNUM = 1;
-- BEGIN

-- SELECT COUNT(EMPLOYEE_ID) INTO V_COUNT FROM NJCT_A_JOB_HISTROY WHERE EMPLOYEE_ID = :OLD.EMPLOYEE_ID;

-- IF (V_COUNT = 0) THEN
-- INSERT INTO NJCT_A_JOB_HISTORY 
-- VALUES (:OLD.EMPLOYEE_ID,:OLD.HIRE_DATE,SYSDATE,:OLD.JOB_ID,:OLD.DEPARTMENT_ID);
-- ELSE
-- --V_EMPLOYEE_ID := :OLD.EMPLOYEE_ID;
-- OPEN CURTRIAL(:OLD.EMPLOYEE_ID);

-- FETCH CURTRIAL INTO V_DATE;

-- INSERT INTO NJCT_A_JOB_HISTORY 
-- VALUES (:OLD.EMPLOYEE_ID,V_DATE + 1,SYSDATE,:OLD.JOB_ID,:OLD.DEPARTMENT_ID);

-- CLOSE CURTRIAL;

-- END IF;

-- END;
/*0000000000000000000*/

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/



WEEKDAY(START_DATE,END_DATE);

CREATE OR REPLACE FUNCTION FNX_WEEK_DAY_TRIAL(START_DATE DATE,LAST_DATE DATE)
RETURN NUMBER
IS
BEGIN
IF (START_DATE < LAST_DATE) THEN

END IF;
END;
/*

COMPARING DATE GRATER AND SMALLER

DECLARE
START_DATE DATE;
LAST_DATE DATE;
BEGIN 

START_DATE := '18-03-01';
LAST_DATE := '19-03-03';

IF (START_DATE < LAST_DATE) THEN
DBMS_OUTPUT.PUT_LINE('WRONG');
ELSE
DBMS_OUTPUT.PUT_LINE('RIGHT');
END IF;

END;
*/
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
-- PROCEDURE THAT GIVES DATE DIFFERENCE OF WEEKDAYS
DECLARE 
START_DATE DATE;
LAST_DATE DATE;
V_DATE DATE;
V_COUNT NUMBER;
BEGIN
START_DATE := '10-02-21';
LAST_DATE := '10-03-21';
IF (START_DATE < LAST_DATE) THEN

V_DATE := START_DATE;
V_COUNT := 0;

LOOP

IF(TO_CHAR(V_DATE,'D') != 1) THEN
V_COUNT := V_COUNT + 1;
END IF;
V_DATE := (V_DATE + 1);
EXIT WHEN V_DATE = LAST_DATE;

END LOOP;
DBMS_OUTPUT.PUT_LINE('NO. OF WEEK DAYS : '|| V_COUNT);
ELSE
DBMS_OUTPUT.PUT_LINE('CHECK THE DATES AGAIN!!!!');
END IF;
END;
-- FUNCTION OF ABOVE
-- SELECT ( SYSDATE + 21 ) FROM DUAL;

CREATE OR REPLACE FUNCTION FNX_WEEK_DAY_TRIAL(START_DATE DATE,LAST_DATE DATE)
RETURN NUMBER
IS

V_DATE DATE;
V_COUNT NUMBER;

BEGIN

IF (START_DATE < LAST_DATE) THEN

V_DATE := START_DATE;
V_COUNT := 0;

LOOP

IF(TO_CHAR(V_DATE,'D') != 1) THEN
V_COUNT := V_COUNT + 1;
END IF;
V_DATE := (V_DATE + 1);
EXIT WHEN V_DATE = LAST_DATE;

END LOOP;
RETURN V_COUNT;
ELSE
RETURN -1;
END IF;

END;

SELECT FNX_WEEK_DAY_TRIAL('10-02-21','10-03-21') FROM DUAL;
SELECT FNX_WEEK_DAY_TRIAL(TO_DATE(SYSDATE),'10-MAR-21') FROM DUAL;

--SELECT * FROM DICTIONARY WHERE TABLE_NAME LIKE '%TRIGG%';
-- SELECT * FROM USER_TRIGGERS WHERE TABLE_NAME LIKE'';
